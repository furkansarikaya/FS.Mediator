<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FS.Mediator</name>
    </assembly>
    <members>
        <member name="T:FS.Mediator.Extensions.ServiceCollectionExtensions">
            <summary>
            Extension methods for configuring FS.Mediator services in the dependency injection container.
            These extensions provide a fluent API for registering handlers, behaviors, and interceptors
            with sensible defaults and powerful customization options.
            </summary>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddFSMediator(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Reflection.Assembly[])">
            <summary>
            Adds FS.Mediator services to the specified service collection.
            This is the foundation method that sets up the core mediator infrastructure.
            </summary>
            <param name="services">The service collection to add services to.</param>
            <param name="assemblies">The assemblies to scan for handlers. If none provided, scans the calling assembly.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddPipelineBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)">
            <summary>
            Adds a pipeline behavior to the service collection.
            Pipeline behaviors are executed in the order they are registered and provide
            cross-cutting concerns like logging, retry logic, and circuit breaking.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="behaviorType">The type of behavior to add.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddLoggingBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Adds logging behavior to the pipeline.
            This behavior logs request processing information including execution time and errors.
            Think of this as your application's "flight recorder" for debugging and monitoring.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddRetryBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions})">
            <summary>
            Adds retry policy behavior to the pipeline.
            This behavior automatically retries failed requests based on configurable strategies,
            significantly improving your application's resilience to transient failures.
            
            Retry policies are particularly valuable in distributed systems where temporary
            network issues, database timeouts, or service overloads can cause requests to fail
            even though the underlying operation could succeed if attempted again.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize retry behavior.
            If not provided, sensible defaults are used (3 retries with exponential backoff).</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddRetryBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,FS.Mediator.Features.Retry.Models.Enums.RetryPreset)">
            <summary>
            Adds retry policy behavior with predefined configuration for common scenarios.
            This method provides several preset configurations that work well for typical use cases,
            saving you from having to understand all the retry theory upfront.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="preset">The preset configuration to use</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddCircuitBreakerBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions})">
            <summary>
            Adds circuit breaker behavior to the pipeline.
            Circuit breaker protects your system from cascade failures by monitoring service health
            and temporarily stopping requests to failing services, giving them time to recover.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize circuit breaker behavior.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddCircuitBreakerBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitBreakerPreset)">
            <summary>
            Adds circuit breaker behavior with predefined configuration for common scenarios.
            These presets represent battle-tested configurations optimized for different types of services.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="preset">The preset configuration to use</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddPerformanceBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Int32)">
            <summary>
            Adds performance monitoring behavior to the pipeline.
            This behavior logs warnings for requests that take longer than the specified threshold.
            Think of this as your "performance watchdog" that alerts you to slow operations.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="warningThresholdMs">The threshold in milliseconds for logging performance warnings. Default is 500ms.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingHealthCheckBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions})">
            <summary>
            Adds comprehensive health check and diagnostics behavior to the streaming pipeline.
            
            This behavior implements a sophisticated health monitoring system that provides
            real-time insights into streaming operation health and performance. Think of it
            as adding a "medical monitoring system" to your streams that continuously
            checks vital signs and alerts you to potential issues.
            
            Key monitoring capabilities:
            - Performance tracking (throughput, latency, resource usage)
            - Health status assessment with configurable thresholds
            - Memory pressure detection and optional automatic management
            - Stall detection for streams that stop producing data
            - Integration with monitoring systems through IStreamHealthReporter
            
            This is particularly valuable for:
            - Long-running data processing operations
            - Critical business processes that need reliability monitoring
            - Production systems where early problem detection is essential
            - Performance optimization and capacity planning
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize health monitoring behavior.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingHealthCheckBehavior``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions},Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Adds health check behavior with a custom health reporter implementation.
            
            This overload allows you to specify exactly which health reporting service to use,
            which is valuable when integrating with specific monitoring systems like
            Application Insights, Prometheus, Datadog, or custom monitoring solutions.
            
            The custom reporter gives you full control over how health metrics are
            collected, formatted, and sent to your monitoring infrastructure.
            </summary>
            <typeparam name="THealthReporter">The type of health reporter to use for monitoring integration.</typeparam>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize health monitoring behavior.</param>
            <param name="reporterLifetime">The service lifetime for the health reporter (default is Scoped).</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingHealthCheckBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,FS.Mediator.Features.HealthChecking.Services.IStreamHealthReporter},System.Action{FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions},Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Adds health check behavior with a factory-created health reporter.
            
            This overload is perfect for scenarios where your health reporter needs
            complex initialization, external configuration, or depends on services
            that aren't easily resolved through standard DI patterns.
            
            For example, if your health reporter needs API keys, connection strings,
            or other configuration that's loaded at runtime, the factory pattern
            gives you complete control over the initialization process.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="healthReporterFactory">Factory function to create the health reporter instance.</param>
            <param name="configureOptions">Optional configuration action to customize health monitoring behavior.</param>
            <param name="reporterLifetime">The service lifetime for the health reporter (default is Scoped).</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingHealthCheckBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,FS.Mediator.Features.HealthChecking.Models.Enums.HealthCheckPreset)">
            <summary>
            Adds health check behavior with predefined configuration optimized for common scenarios.
            
            These presets provide battle-tested configurations that work well for typical
            streaming scenarios, eliminating the need to understand all the individual
            configuration options upfront. Each preset is optimized for different types
            of streaming operations and their characteristic performance patterns.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="preset">The preset configuration optimized for specific scenarios.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingPipelineBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Type)">
            <summary>
            Adds a streaming pipeline behavior to the service collection.
            Streaming behaviors are executed in the order they are registered and provide
            cross-cutting concerns specifically designed for stream operations like logging,
            retry logic, and performance monitoring for continuous data flows.
            
            The key difference from regular behaviors is that streaming behaviors work with
            IAsyncEnumerable flows rather than single request/response pairs.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="behaviorType">The type of streaming behavior to add.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingLoggingBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.Logging.Models.Options.StreamingLoggingOptions})">
            <summary>
            Adds streaming logging behavior to the pipeline.
            This behavior provides specialized logging for stream operations, including:
            - Stream initiation and completion logging
            - Periodic progress updates (configurable by item count or time intervals)
            - Performance metrics (items per second, total duration)
            - Error tracking and failure analysis
            
            Unlike regular request logging, streaming logging is designed to handle
            long-running operations that process thousands or millions of items without
            overwhelming your log files.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize logging behavior.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingRetryBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions})">
            <summary>
            Adds streaming retry behavior to the pipeline.
            This behavior implements intelligent retry logic specifically designed for streaming operations:
            
            Key features:
            - Handles partial stream failures (stream yields some items then fails)
            - Configurable retry strategies (restart from beginning vs resume from failure point)
            - Intelligent backoff algorithms to avoid overwhelming failing systems
            - Time-based circuit breaking to prevent infinite retry loops
            
            Streaming retry is fundamentally different from regular request retry because
            streams can partially succeed. A stream that yields 1000 items then fails might
            be worth retrying, but reprocessing those 1000 items might be expensive.
            This behavior provides strategies to handle these scenarios efficiently.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize retry behavior.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingCircuitBreakerBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions})">
            <summary>
            Adds streaming circuit breaker behavior to the pipeline.
            This behavior implements circuit breaker pattern specifically for streaming operations:
            
            Key features:
            - Stream-level failure tracking (tracks failed streams, not individual items)
            - Partial success consideration (streams that yield many items before failing)
            - Longer time windows (streaming operations typically run longer than regular requests)
            - Conservative trial periods (fewer test streams during recovery)
            
            Streaming circuit breakers protect your system from cascade failures caused by
            problematic stream operations. They're especially valuable when streaming from
            external APIs, databases, or file systems that might become unavailable.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize circuit breaker behavior.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingPerformanceBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.Performance.Models.Options.StreamingPerformanceOptions})">
            <summary>
            Adds streaming performance monitoring behavior to the pipeline.
            This behavior monitors streaming operations for performance issues:
            
            Key metrics tracked:
            - Time to first item (how quickly does the stream start producing results?)
            - Throughput (items per second - is the stream processing data efficiently?)
            - Total duration (is the stream taking longer than expected?)
            - Progress tracking (periodic performance checks during long operations)
            
            This is invaluable for identifying bottlenecks in streaming operations.
            Slow streams can impact user experience and system resources, so monitoring
            helps you optimize performance and set appropriate expectations.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize performance monitoring.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingResiliencePackage(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Adds a complete streaming resilience package with sensible defaults.
            This is a convenience method that adds logging, retry, circuit breaker, and
            performance monitoring behaviors with configurations optimized for most streaming scenarios.
            
            Think of this as your "streaming safety net" - it provides comprehensive
            protection and monitoring for streaming operations without requiring you
            to understand all the individual configuration options upfront.
            
            The included behaviors work together to provide:
            - Comprehensive visibility (logging and performance monitoring)
            - Fault tolerance (retry and circuit breaker)
            - Optimal performance (intelligent retry strategies and performance tracking)
            </summary>
            <param name="services">The service collection to add behaviors to.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddResourceManagementBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions})">
            <summary>
            Adds resource management behavior to the pipeline.
            
            Resource management is like having a careful housekeeper for your application -
            it continuously monitors memory usage, tracks disposable resources, and takes
            corrective action when resource pressure builds up.
            
            This behavior is particularly valuable for:
            - Long-running applications that process many requests
            - Memory-constrained environments (containers, embedded systems)
            - Applications with complex object lifecycles
            - Systems that need to prevent memory-related crashes
            
            Think of this as your application's "resource bodyguard" that ensures
            your system stays healthy even under demanding conditions.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize resource management behavior.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddResourceManagementBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset)">
            <summary>
            Adds resource management behavior with predefined configuration for common scenarios.
            These presets provide battle-tested configurations optimized for different deployment scenarios.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="preset">The preset configuration to use</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingResourceManagementBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions})">
            <summary>
            Adds streaming resource management behavior to the pipeline.
            
            Streaming resource management is even more critical than regular resource management
            because streams can run for hours or days, making any resource leak catastrophic.
            
            This behavior is like having a dedicated "stream shepherd" that:
            - Monitors memory usage as data flows through
            - Prevents resource accumulation over time
            - Takes corrective action before problems become critical
            - Maintains stream health without interrupting data flow
            
            Essential for:
            - Large data processing operations (ETL, analytics)
            - Real-time data streams that run continuously
            - Long-running batch operations
            - Any stream that processes significant amounts of data
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize streaming resource management.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingResourceManagementBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset)">
            <summary>
            Adds streaming resource management behavior with predefined configuration for common scenarios.
            These presets provide battle-tested configurations optimized for different streaming scenarios.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="preset">The preset configuration to use</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingBackpressureBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Action{FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions})">
            <summary>
            Adds streaming backpressure handling behavior to the pipeline.
            
            Backpressure handling is like having a skilled traffic manager for your data streams.
            When data producers are faster than consumers, this behavior implements sophisticated
            strategies to maintain system stability and prevent crashes.
            
            Think of backpressure as your "data traffic control system" that:
            - Monitors the flow rate of data through your system
            - Detects when consumers can't keep up with producers
            - Applies appropriate strategies to maintain system stability
            - Prevents memory exhaustion and system crashes
            
            Critical for:
            - High-throughput data processing systems
            - Real-time streaming applications
            - Systems with variable processing speeds
            - Applications that need to handle traffic spikes gracefully
            
            The behavior offers multiple strategies (Buffer, Drop, Throttle, Sample, Block)
            each optimized for different trade-offs between throughput, latency, and data completeness.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="configureOptions">Optional configuration action to customize backpressure handling.</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingBackpressureBehavior(Microsoft.Extensions.DependencyInjection.IServiceCollection,FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset)">
            <summary>
            Adds streaming backpressure behavior with predefined configuration for common scenarios.
            These presets represent different philosophies for handling producer-consumer speed mismatches.
            </summary>
            <param name="services">The service collection to add the behavior to.</param>
            <param name="preset">The preset configuration to use</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddStreamingPlatinumPackage(Microsoft.Extensions.DependencyInjection.IServiceCollection,FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset,FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset)">
            <summary>
            Adds a complete streaming resilience and efficiency package.
            This combines resource management and backpressure handling with the existing
            resilience package for comprehensive stream protection.
            
            Think of this as the "premium protection plan" for your streaming operations.
            It provides:
            - **Resource Management**: Prevents memory leaks and resource exhaustion
            - **Backpressure Handling**: Manages producer-consumer speed mismatches
            - **Retry Logic**: Handles transient failures gracefully
            - **Circuit Breaking**: Protects against cascade failures
            - **Performance Monitoring**: Tracks stream health and efficiency
            - **Comprehensive Logging**: Provides visibility into all operations
            
            This package is recommended for production streaming systems where
            reliability, efficiency, and observability are all critical requirements.
            </summary>
            <param name="services">The service collection to add behaviors to.</param>
            <param name="resourcePreset">Resource management preset (default: Balanced)</param>
            <param name="backpressurePreset">Backpressure preset (default: Balanced)</param>
            <returns>The service collection for chaining.</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddRequestInterceptor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Registers a typed request interceptor for specific request and response types.
            Request interceptors execute before the pipeline and are perfect for request validation,
            transformation, and security checks. Think of them as "request guards" that ensure
            only properly formatted and authorized requests enter your system.
            </summary>
            <typeparam name="TRequest">The type of request to intercept</typeparam>
            <typeparam name="TResponse">The type of response expected</typeparam>
            <typeparam name="TInterceptor">The interceptor implementation type</typeparam>
            <param name="services">The service collection to register with</param>
            <param name="serviceLifetime">The service lifetime (default is Scoped)</param>
            <returns>The service collection for chaining</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddRequestInterceptor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``2},Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Registers a typed request interceptor using a factory function.
            This overload is useful when your interceptor needs complex initialization
            or depends on runtime configuration that can't be resolved through DI alone.
            </summary>
            <typeparam name="TRequest">The type of request to intercept</typeparam>
            <typeparam name="TResponse">The type of response expected</typeparam>
            <typeparam name="TInterceptor">The interceptor implementation type</typeparam>
            <param name="services">The service collection to register with</param>
            <param name="factory">Factory function to create the interceptor</param>
            <param name="serviceLifetime">The service lifetime (default is Scoped)</param>
            <returns>The service collection for chaining</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddResponseInterceptor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Registers a typed response interceptor for specific request and response types.
            Response interceptors execute after the pipeline completes successfully and are perfect
            for response transformation, caching, and enrichment. Think of them as "response
            enhancers" that add value to your outgoing data.
            </summary>
            <typeparam name="TRequest">The type of request that generates the response</typeparam>
            <typeparam name="TResponse">The type of response to intercept</typeparam>
            <typeparam name="TInterceptor">The interceptor implementation type</typeparam>
            <param name="services">The service collection to register with</param>
            <param name="serviceLifetime">The service lifetime (default is Scoped)</param>
            <returns>The service collection for chaining</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddResponseInterceptor``3(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Func{System.IServiceProvider,``2},Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Registers a typed response interceptor using a factory function.
            This overload provides flexibility for complex interceptor initialization scenarios.
            </summary>
            <typeparam name="TRequest">The type of request that generates the response</typeparam>
            <typeparam name="TResponse">The type of response to intercept</typeparam>
            <typeparam name="TInterceptor">The interceptor implementation type</typeparam>
            <param name="services">The service collection to register with</param>
            <param name="factory">Factory function to create the interceptor</param>
            <param name="serviceLifetime">The service lifetime (default is Scoped)</param>
            <returns>The service collection for chaining</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddGlobalRequestInterceptor``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Registers a global request interceptor that can process any request type.
            Global interceptors are powerful tools for implementing system-wide concerns
            like security, auditing, and correlation tracking that apply to all requests.
            </summary>
            <typeparam name="TInterceptor">The global interceptor implementation type</typeparam>
            <param name="services">The service collection to register with</param>
            <param name="serviceLifetime">The service lifetime (default is Scoped)</param>
            <returns>The service collection for chaining</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.AddGlobalResponseInterceptor``1(Microsoft.Extensions.DependencyInjection.IServiceCollection,Microsoft.Extensions.DependencyInjection.ServiceLifetime)">
            <summary>
            Registers a global response interceptor that can process any response type.
            Global response interceptors are ideal for cross-cutting concerns that need to
            affect all outgoing responses, such as adding security headers or performance metrics.
            </summary>
            <typeparam name="TInterceptor">The global interceptor implementation type</typeparam>
            <param name="services">The service collection to register with</param>
            <param name="serviceLifetime">The service lifetime (default is Scoped)</param>
            <returns>The service collection for chaining</returns>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.RegisterHandlers(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Reflection.Assembly[])">
            <summary>
            Scans assemblies for request handlers, stream handlers, and notification handlers.
            This method uses reflection to automatically discover and register all handler types,
            saving you from having to manually register each one.
            </summary>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.RegisterInterceptors(Microsoft.Extensions.DependencyInjection.IServiceCollection,System.Reflection.Assembly[])">
            <summary>
            Scans assemblies for interceptor implementations and registers them automatically.
            This provides a convention-based approach where any class implementing interceptor
            interfaces will be automatically discovered and registered.
            </summary>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.GetHandlerTypes(System.Reflection.Assembly[])">
            <summary>
            Discovers all handler types in the provided assemblies using reflection.
            This method looks for classes that implement the core handler interfaces.
            </summary>
        </member>
        <member name="M:FS.Mediator.Extensions.ServiceCollectionExtensions.GetInterceptorTypes(System.Reflection.Assembly[])">
            <summary>
            Discovers all interceptor types in the provided assemblies using reflection.
            This method looks for classes that implement any of the interceptor interfaces.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2">
            <summary>
            Streaming pipeline behavior that handles backpressure when consumers cannot keep up with producers.
            
            Imagine you're managing a busy restaurant where orders come in faster than the kitchen can prepare them.
            Without proper management, you'd have several problems:
            1. The order queue would grow infinitely (memory exhaustion)
            2. Customers would wait forever (poor user experience)  
            3. The kitchen would be overwhelmed (system instability)
            4. Eventually, the restaurant would collapse (system failure)
            
            Backpressure management is like being a skilled maître d' who:
            - **Monitors the Queue**: Watches how many orders are waiting
            - **Measures Kitchen Speed**: Tracks how fast orders are being completed
            - **Takes Action**: Implements strategies when the kitchen falls behind
            - **Maintains Quality**: Ensures the restaurant continues operating smoothly
            
            This behavior implements several sophisticated strategies for handling producer-consumer
            speed mismatches, ensuring your streaming operations remain stable and predictable
            even under extreme load conditions.
            
            The key insight is that controlled degradation is always better than system failure.
            It's better to intentionally drop some data or slow down processing than to have
            your entire system crash from memory exhaustion.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior{`0,`1}},FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions)">
            <summary>
            Streaming pipeline behavior that handles backpressure when consumers cannot keep up with producers.
            
            Imagine you're managing a busy restaurant where orders come in faster than the kitchen can prepare them.
            Without proper management, you'd have several problems:
            1. The order queue would grow infinitely (memory exhaustion)
            2. Customers would wait forever (poor user experience)  
            3. The kitchen would be overwhelmed (system instability)
            4. Eventually, the restaurant would collapse (system failure)
            
            Backpressure management is like being a skilled maître d' who:
            - **Monitors the Queue**: Watches how many orders are waiting
            - **Measures Kitchen Speed**: Tracks how fast orders are being completed
            - **Takes Action**: Implements strategies when the kitchen falls behind
            - **Maintains Quality**: Ensures the restaurant continues operating smoothly
            
            This behavior implements several sophisticated strategies for handling producer-consumer
            speed mismatches, ensuring your streaming operations remain stable and predictable
            even under extreme load conditions.
            
            The key insight is that controlled degradation is always better than system failure.
            It's better to intentionally drop some data or slow down processing than to have
            your entire system crash from memory exhaustion.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.ShouldApplyBackpressureAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession)">
            <summary>
            Determines whether backpressure should be applied based on current system conditions.
            This is like checking the restaurant's "vital signs" - queue length, kitchen speed, customer satisfaction.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.ApplyBackpressureStrategyAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession,`1,System.Threading.Channels.ChannelWriter{FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureWrapper{`1}},System.Threading.CancellationToken)">
            <summary>
            Applies the configured backpressure strategy to handle the current item.
            This is where we implement the different "restaurant management" strategies.
            
            Think of each strategy as a different management philosophy:
            - Buffer: "Let's take more orders and hope the kitchen catches up"
            - Drop: "Sorry, we're full - come back later"  
            - Throttle: "Please wait a moment before ordering"
            - Sample: "We're only taking every other order right now"
            - Block: "Kitchen is backed up - no new orders until we catch up"
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.ApplyBufferStrategyAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession,`1,System.Threading.Channels.ChannelWriter{FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureWrapper{`1}},System.Threading.CancellationToken)">
            <summary>
            Buffer strategy: Continue queuing items but with awareness of limits.
            This is like a restaurant that keeps taking orders even when the kitchen is slow,
            hoping things will catch up. Risky but maintains customer satisfaction when it works.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.ApplyDropStrategyAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession,`1,System.Threading.Channels.ChannelWriter{FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureWrapper{`1}},System.Threading.CancellationToken)">
            <summary>
            Drop strategy: Discard items when under pressure.
            This is like a restaurant that stops taking orders when the kitchen is overwhelmed.
            Maintains system stability at the cost of losing some data.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.ApplyThrottleStrategyAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession,`1,System.Threading.Channels.ChannelWriter{FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureWrapper{`1}},System.Threading.CancellationToken)">
            <summary>
            Throttle strategy: Slow down the producer by introducing delays.
            This is like asking customers to wait before placing orders when the kitchen is busy.
            Maintains data completeness but reduces overall throughput.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.ApplySampleStrategyAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession,`1,System.Threading.Channels.ChannelWriter{FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureWrapper{`1}},System.Threading.CancellationToken)">
            <summary>
            Sample strategy: Only process a subset of items when under pressure.
            This is like a restaurant that only takes every nth order when the kitchen is overwhelmed.
            Maintains system responsiveness but intentionally loses data for statistical processing.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.ApplyBlockStrategyAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession,`1,System.Threading.Channels.ChannelWriter{FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureWrapper{`1}},System.Threading.CancellationToken)">
            <summary>
            Block strategy: Completely halt producer until consumer catches up.
            This is like a restaurant that stops taking any orders until the kitchen clears its backlog.
            Ensures no data loss but can significantly impact throughput.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.PerformPeriodicMonitoringAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession)">
            <summary>
            Performs periodic monitoring of backpressure metrics and system health.
            This is like a restaurant manager doing regular rounds to check on operations.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.CreateBackpressureMetrics(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession)">
            <summary>
            Creates a BackpressureMetrics object with current session data.
            This provides a snapshot of the current system state for decision making.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.LogProducerCompletionAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession)">
            <summary>
            Logs producer completion statistics for analysis and monitoring.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.LogFinalBackpressureStatsAsync(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession)">
            <summary>
            Logs final backpressure statistics when the stream completes.
            This provides a comprehensive summary for performance analysis.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.CalculateBackpressureEffectiveness(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession)">
            <summary>
            Calculates the effectiveness of backpressure handling for this session.
            Returns a score from 0 (completely ineffective) to 100 (perfectly effective).
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Backpressure.Behaviors.Streaming.StreamingBackpressureBehavior`2.GetStrategySpecificMetrics(FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession)">
            <summary>
            Gets strategy-specific metrics based on the backpressure strategy used.
            Different strategies have different relevant metrics to track.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureWrapper`1">
            <summary>
            Wrapper class that carries additional metadata about items flowing through the backpressure system.
            This is like attaching a "receipt" to each order in our restaurant that tracks when it was created
            and what processing it has undergone.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Behaviors.Streaming.BackpressureSession">
            <summary>
            Tracks the state and metrics for a single backpressure management session.
            This is like the manager's logbook that records everything happening in the restaurant.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Models.BackpressureContext">
            <summary>
            Context information provided when backpressure is triggered.
            This gives custom handlers access to current state and metrics.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureContext.Strategy">
            <summary>
            Gets the strategy being applied to handle backpressure.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureContext.Metrics">
            <summary>
            Gets the current metrics that triggered backpressure.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureContext.TriggeredAt">
            <summary>
            Gets the timestamp when backpressure was triggered.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureContext.RequestType">
            <summary>
            Gets the type of request being processed when backpressure occurred.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureContext.Properties">
            <summary>
            Gets custom properties that can be set by the backpressure behavior.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics">
            <summary>
            Metrics used for making backpressure decisions.
            This data helps the system understand current load and performance characteristics.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics.CurrentBufferSize">
            <summary>
            Current number of items in the buffer.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics.MaxBufferSize">
            <summary>
            Maximum allowed buffer size.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics.ProducerRate">
            <summary>
            Rate at which items are being produced (items per second).
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics.ConsumerRate">
            <summary>
            Rate at which items are being consumed (items per second).
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics.BackpressureDuration">
            <summary>
            How long backpressure has been active (null if not currently active).
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics.MemoryUsage">
            <summary>
            Current memory usage in bytes.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.BackpressureMetrics.CustomMetrics">
            <summary>
            Additional custom metrics that can be used for decision making.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset">
            <summary>
            Predefined backpressure configurations optimized for different data processing scenarios.
            
            These presets represent different "traffic management philosophies" for handling
            situations where data producers are faster than consumers. Each preset embodies
            a different set of trade-offs between throughput, latency, data completeness,
            and resource usage.
            
            Think of these as choosing the right traffic management strategy for different
            types of roads and traffic patterns.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset.NoDataLoss">
            <summary>
            Prioritizes data completeness - no data should ever be lost.
            
            This preset is like having a "data preservation specialist" who treats
            every piece of information as precious and irreplaceable. Performance
            may suffer, but data integrity is paramount.
            
            Strategy: Throttle with large buffers
            Trade-offs: Maximum data completeness, higher latency, more memory usage
            
            Configuration highlights:
            - Uses Throttle strategy to slow down producers
            - Large buffer sizes (50,000 items)
            - High watermark threshold (90%)
            - Accepts significant delays (up to 5 seconds)
            - Detailed metrics for monitoring
            
            Best for:
            - Financial transaction processing
            - Critical business data pipelines
            - Audit logging systems
            - Medical records processing
            - Any system where data loss is unacceptable
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset.HighThroughput">
            <summary>
            Optimized for maximum throughput and system responsiveness.
            
            This preset is like having a "performance-focused traffic manager" who
            keeps traffic flowing smoothly even if it means some cars have to take
            alternate routes. Speed and responsiveness are prioritized over completeness.
            
            Strategy: Drop with moderate buffers and early intervention
            Trade-offs: Highest throughput, lowest latency, potential data loss
            
            Configuration highlights:
            - Uses Drop strategy to maintain flow
            - Moderate buffer sizes (10,000 items)
            - Early intervention (70% watermark)
            - Prefers newer items over older ones
            - Detailed metrics for optimization
            
            Best for:
            - Real-time monitoring systems
            - Live dashboards and analytics
            - High-frequency sensor data
            - Social media feeds
            - Systems where approximate data is sufficient
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset.MemoryConstrained">
            <summary>
            Optimized for environments with severe memory limitations.
            
            This preset is like having a "resource-conscious manager" who operates
            within strict constraints, making hard choices to ensure the system
            stays within its limits.
            
            Strategy: Sample with very small buffers
            Trade-offs: Minimal memory usage, statistical data preservation, reduced completeness
            
            Configuration highlights:
            - Uses Sample strategy for bounded memory
            - Very small buffer sizes (1,000 items)
            - Very early intervention (50% watermark)
            - Samples every 2nd item under pressure
            - Minimal metrics overhead
            
            Best for:
            - IoT devices with limited RAM
            - Edge computing scenarios
            - Embedded systems
            - Container environments with strict memory limits
            - Microservices in resource-constrained clusters
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset.RealTime">
            <summary>
            Optimized for real-time applications where freshness is critical.
            
            This preset is like having a "real-time news director" who always wants
            the latest information and is willing to discard older news to make
            room for breaking stories.
            
            Strategy: Drop with focus on latest data and quick response
            Trade-offs: Ultra-low latency, always fresh data, some data loss
            
            Configuration highlights:
            - Uses Drop strategy for predictable latency
            - Small buffers for low latency (5,000 items)
            - Quick response to pressure (60% watermark)
            - Always prefer newer items
            - Fast measurement windows (10 seconds)
            
            Best for:
            - Live video streaming
            - Real-time gaming
            - Stock price feeds
            - Live sports data
            - Interactive user interfaces
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset.Analytics">
            <summary>
            Optimized for analytics where statistical sampling is acceptable.
            
            This preset is like having a "statistical analyst" who understands that
            you don't need every data point to get meaningful insights - a well-chosen
            sample can provide accurate results with much better resource efficiency.
            
            Strategy: Adaptive sampling with intelligent metrics
            Trade-offs: Statistically valid results, efficient resource usage, controlled data reduction
            
            Configuration highlights:
            - Uses Sample strategy with adaptive behavior
            - Large buffers for batch processing (25,000 items)
            - Intelligent sampling (10% under pressure)
            - Adaptive backpressure that learns from patterns
            - Comprehensive metrics for analysis
            
            Best for:
            - Business intelligence systems
            - User behavior analytics
            - Performance monitoring
            - Market research data
            - Scientific data processing
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressurePreset.Balanced">
            <summary>
            Balanced configuration suitable for most general-purpose streaming scenarios.
            
            This preset is like having a "sensible traffic manager" who applies
            proven strategies that work well in most situations. It provides
            good performance without extreme trade-offs in any direction.
            
            Strategy: Buffer with reasonable limits and monitoring
            Trade-offs: Good balance of throughput, latency, and data completeness
            
            Configuration highlights:
            - Uses Buffer strategy with reasonable limits
            - Standard buffer sizes (10,000 items)
            - Balanced watermark thresholds (80%/50%)
            - Comprehensive metrics collection
            - Suitable for most workloads
            
            Best for:
            - General business applications
            - Standard data processing pipelines
            - Most web applications
            - Typical microservice scenarios
            - When you're unsure which strategy to choose
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Models.Enums.BackpressureStrategy">
            <summary>
            Defines different strategies for handling backpressure when consumers can't keep up with producers.
            Each strategy represents a different trade-off between resource usage, data loss, and system stability.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressureStrategy.Buffer">
            <summary>
            Buffer items in memory until consumer catches up.
            
            **Pros:**
            - No data loss - all items eventually processed
            - Simple to understand and implement
            - Good for temporary spikes in load
            
            **Cons:**
            - Can consume unlimited memory
            - Risk of OutOfMemoryException
            - Latency increases as buffer grows
            
            **Best for:**
            - Systems with predictable memory limits
            - Temporary load spikes (not sustained overload)
            - Critical data that cannot be lost
            - Systems with fast consumers that just need smoothing
            
            **Example:** Processing payment transactions - every transaction is important
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressureStrategy.Drop">
            <summary>
            Drop items when buffer capacity is exceeded.
            
            **Pros:**
            - Bounded memory usage
            - System remains stable under any load
            - Low latency for items that are processed
            
            **Cons:**
            - Data loss when overwhelmed
            - May lose important information
            - Requires careful monitoring of drop rates
            
            **Best for:**
            - Real-time systems where freshness matters more than completeness
            - Monitoring/telemetry data with redundancy
            - Systems where some data loss is acceptable
            
            **Example:** Server monitoring metrics - dropping a few data points is okay
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressureStrategy.Throttle">
            <summary>
            Slow down the producer by introducing delays.
            
            **Pros:**
            - No data loss
            - Bounded memory usage
            - Automatically adjusts to consumer capacity
            
            **Cons:**
            - Reduces overall throughput
            - May cause timeouts in producer
            - Can create cascading delays in distributed systems
            
            **Best for:**
            - Systems where producer can tolerate delays
            - Batch processing scenarios
            - When data completeness is critical but timing is flexible
            
            **Example:** ETL data processing - better to process slowly than lose data
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressureStrategy.Sample">
            <summary>
            Process only a subset of items when under pressure.
            
            **Pros:**
            - Bounded memory usage
            - Maintains system responsiveness
            - Good for statistical/approximate processing
            
            **Cons:**
            - Data loss (by design)
            - May miss important items
            - Requires careful selection of which items to process
            
            **Best for:**
            - Analytics where sampling is statistically valid
            - Systems with highly redundant data
            - When approximate results are acceptable
            
            **Example:** Website analytics - processing 1 in 10 page views still gives valid insights
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Backpressure.Models.Enums.BackpressureStrategy.Block">
            <summary>
            Block the producer completely until consumer catches up.
            
            **Pros:**
            - No data loss
            - Simple backpressure mechanism
            - Clear producer-consumer coordination
            
            **Cons:**
            - Can cause producer timeouts
            - May create deadlocks in some scenarios
            - Reduces system throughput significantly
            
            **Best for:**
            - Synchronous processing scenarios
            - When data order and completeness are critical
            - Systems with well-coordinated producers and consumers
            
            **Example:** Database replication - ensure all changes are processed in order
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions">
            <summary>
            Configuration options for backpressure handling in streaming operations.
            
            Backpressure is like traffic management for your data streams. Imagine you're running
            a restaurant kitchen where orders come in faster than the chefs can prepare them.
            You have several options:
            
            1. **Buffer Strategy**: Keep a reasonable queue of orders (but not unlimited)
            2. **Drop Strategy**: Start rejecting new orders when overwhelmed  
            3. **Throttle Strategy**: Slow down accepting new orders to match cooking speed
            4. **Sample Strategy**: Only process every nth order when under pressure
            
            Each strategy has trade-offs between resource usage, data completeness, and system stability.
            The key insight is that doing something intentional is always better than letting the
            system crash from resource exhaustion.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.Strategy">
            <summary>
            Gets or sets the backpressure strategy to use when consumer cannot keep up with producer.
            This is your fundamental decision about how to handle overwhelming data flows.
            Default is Buffer - safe but memory-intensive.
            
            Think of this as choosing your "traffic management" philosophy:
            - Buffer: "Let's queue them up and hope traffic clears"
            - Drop: "Turn away cars when the road is full"
            - Throttle: "Control the traffic lights to manage flow"
            - Sample: "Only let every 3rd car through during rush hour"
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.MaxBufferSize">
            <summary>
            Gets or sets the maximum number of items to buffer before applying backpressure.
            This acts as your "early warning system" - when the buffer reaches this size,
            backpressure strategies kick in. Default is 10,000 items.
            
            Setting this value requires understanding your data:
            - Small objects (strings, numbers): 50,000-100,000 items
            - Medium objects (small DTOs): 10,000-25,000 items  
            - Large objects (images, documents): 1,000-5,000 items
            - Huge objects (videos, large files): 100-1,000 items
            
            Remember: It's better to trigger backpressure early than to run out of memory!
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.HighWaterMarkThreshold">
            <summary>
            Gets or sets the high watermark threshold (as percentage of MaxBufferSize) where backpressure begins.
            This provides a "yellow light" warning before hitting the "red light" maximum.
            Default is 80% - start applying pressure before the buffer is completely full.
            
            Example: With MaxBufferSize=10,000 and HighWaterMark=0.8, backpressure starts at 8,000 items.
            This gives your system time to react gracefully rather than hitting a hard wall.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.LowWaterMarkThreshold">
            <summary>
            Gets or sets the low watermark threshold (as percentage of MaxBufferSize) where backpressure relief begins.
            This provides hysteresis - once backpressure starts, we don't stop it immediately when buffer drops.
            Default is 50% - only relieve pressure when buffer is significantly reduced.
            
            This prevents "flapping" - rapidly turning backpressure on and off, which can cause instability.
            Think of it like a thermostat with a dead zone to prevent constant cycling.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.MaxThrottleDelayMs">
            <summary>
            Gets or sets the maximum delay to introduce when throttling producers (in milliseconds).
            This is your "brake pedal" - how hard you slow down the producer when needed.
            Default is 1000ms (1 second) maximum delay.
            
            Throttling works by adding delays to producer operations:
            - Light pressure: 10-100ms delays (barely noticeable)
            - Medium pressure: 100-500ms delays (noticeable but tolerable)
            - Heavy pressure: 500-1000ms delays (significant but prevents crash)
            
            Set this based on your latency requirements and user expectations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.SampleRate">
            <summary>
            Gets or sets the sampling rate when using the Sample strategy (1 = process all, 2 = every other, 3 = every third, etc.).
            This is your "data diet" - when overwhelmed, only process a fraction of incoming data.
            Default is 2 (process every other item).
            
            Sampling is useful when:
            - Data is redundant (multiple sensors reporting similar readings)
            - Approximate results are acceptable (analytics, monitoring)
            - System stability is more important than data completeness
            
            Example: SampleRate=5 means process 1 out of every 5 items (20% of data)
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.MeasurementWindowSeconds">
            <summary>
            Gets or sets the time window for measuring producer vs consumer rates (in seconds).
            This is your "measurement window" for detecting when backpressure is needed.
            Default is 30 seconds - long enough to be meaningful, short enough to be responsive.
            
            Shorter windows (5-15 seconds):
            - More responsive to sudden spikes
            - May trigger false alarms from temporary fluctuations
            
            Longer windows (60-300 seconds):
            - More stable, avoids false alarms
            - Less responsive to genuine problems
            
            The sweet spot is usually 15-60 seconds depending on your data patterns.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.PreferNewerItems">
            <summary>
            Gets or sets whether to prioritize newer or older items when dropping under pressure.
            true = drop older items (tail drop), false = drop newer items (head drop).
            Default is true - keep the most recent data.
            
            This is a crucial business decision:
            
            **Drop Older Items (true)**:
            - Best for real-time data (stock prices, sensor readings)
            - Ensures you always have the latest information
            - Example: Keep the most recent temperature readings, discard old ones
            
            **Drop Newer Items (false)**:
            - Best for historical/sequential data (log processing, event streams)
            - Maintains chronological order and completeness
            - Example: Process log entries in order, reject new ones if overwhelmed
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.EnableAdaptiveBackpressure">
            <summary>
            Gets or sets whether to enable adaptive backpressure that adjusts strategy based on conditions.
            When enabled, the system can automatically switch between strategies for optimal performance.
            Default is false - use a single consistent strategy.
            
            Adaptive backpressure is like having a smart traffic management system that:
            - Uses different strategies based on traffic patterns
            - Learns from historical data to make better decisions
            - Automatically adjusts thresholds based on system performance
            
            Enable this for:
            - Variable workloads with unpredictable patterns
            - Systems that need to optimize for different objectives over time
            - Production systems with sophisticated monitoring
            
            Keep disabled for:
            - Predictable workloads
            - Systems where consistency is more important than optimization
            - Development/testing environments
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.CustomBackpressureTrigger">
            <summary>
            Gets or sets custom logic for determining when to apply backpressure.
            This allows you to implement domain-specific backpressure triggers beyond simple buffer size.
            
            Example custom triggers:
            - Memory usage exceeds threshold
            - CPU utilization too high
            - Database connection pool exhausted
            - External API rate limits approaching
            - Business rules (market closed, maintenance window)
            
            The function receives current metrics and should return true to trigger backpressure.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.CustomBackpressureHandler">
            <summary>
            Gets or sets custom logic for handling backpressure situations.
            This allows you to implement domain-specific responses beyond the standard strategies.
            
            Example custom handlers:
            - Notify administrators of the situation
            - Switch to alternative data sources
            - Trigger auto-scaling in cloud environments
            - Store overflow data to persistent storage
            - Update monitoring dashboards
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Backpressure.Models.Options.BackpressureOptions.CollectDetailedMetrics">
            <summary>
            Gets or sets whether to collect detailed metrics about backpressure events.
            This provides valuable insights for tuning and monitoring but adds overhead.
            Default is true - metrics are crucial for understanding backpressure behavior.
            
            Detailed metrics include:
            - Frequency and duration of backpressure events
            - Effectiveness of different strategies
            - Producer vs consumer rate comparisons
            - Buffer utilization patterns
            - Impact on system performance
            
            This data is essential for:
            - Optimizing backpressure configuration
            - Capacity planning
            - Understanding system behavior under load
            - Troubleshooting performance issues
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerBehavior`2">
            <summary>
            Pipeline behavior that implements circuit breaker pattern for protecting against cascade failures.
            
            The circuit breaker monitors the failure rate of requests and automatically opens
            when failures exceed the configured threshold, preventing further requests from
            hitting the failing service and giving it time to recover.
            
            This behavior is particularly valuable in microservice architectures where
            one failing service can bring down the entire system if not properly isolated.
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerBehavior{`0,`1}},FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions)">
            <summary>
            Pipeline behavior that implements circuit breaker pattern for protecting against cascade failures.
            
            The circuit breaker monitors the failure rate of requests and automatically opens
            when failures exceed the configured threshold, preventing further requests from
            hitting the failing service and giving it time to recover.
            
            This behavior is particularly valuable in microservice architectures where
            one failing service can bring down the entire system if not properly isolated.
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerBehavior`2.HandleAsync(`0,FS.Mediator.Features.RequestHandling.Core.RequestHandlerDelegate{`1},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState">
            <summary>
            Manages the state and statistics for a circuit breaker.
            This class is thread-safe and handles the complex logic of state transitions
            and failure tracking across concurrent requests.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState.#ctor(FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions)">
            <summary>
            Initializes a new circuit breaker state with the specified options.
            </summary>
            <param name="options">Configuration options for the circuit breaker</param>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState.CurrentState">
            <summary>
            Gets the current state of the circuit breaker.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState.ShouldAllowRequest">
            <summary>
            Determines whether a request should be allowed through the circuit breaker.
            This is the main decision point that implements the circuit breaker logic.
            </summary>
            <returns>True if the request should be allowed, false if it should be rejected immediately</returns>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState.RecordResult(System.Boolean,System.Exception)">
            <summary>
            Records the result of a request execution.
            This method updates the circuit breaker's internal state based on success or failure.
            </summary>
            <param name="success">Whether the request succeeded</param>
            <param name="exception">The exception if the request failed, null if successful</param>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState.ShouldTripCircuit">
            <summary>
            Determines if the circuit should trip (open) based on current failure statistics.
            This implements the mathematical logic for failure threshold detection.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState.CleanupOldRequests">
            <summary>
            Removes old request records that fall outside the sampling window.
            This maintains a rolling window of statistics for decision making.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Behaviors.CircuitBreakerState.RequestResult">
            <summary>
            Represents the result of a single request for statistical tracking.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Behaviors.Streaming.StreamingCircuitBreakerBehavior`2">
            <summary>
            Streaming pipeline behavior that implements circuit breaker pattern for stream operations.
            
            Circuit breaker for streams protects against cascade failures by monitoring stream-level
            failures rather than individual item failures. This implementation uses the channel pattern
            to ensure circuit breaker logic (with try-catch) is completely separated from yielding.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Exceptions.CircuitBreakerOpenException">
            <summary>
            Circuit breaker exception thrown when requests are rejected due to an open circuit.
            This exception indicates that the circuit breaker is protecting the system
            by failing fast rather than attempting to call a failing service.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Exceptions.CircuitBreakerOpenException.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the CircuitBreakerOpenException.
            </summary>
            <param name="requestType">The type of request that was rejected</param>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Exceptions.CircuitBreakerOpenException.RequestType">
            <summary>
            Gets the type of request that was rejected by the circuit breaker.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitBreakerPreset">
            <summary>
            Predefined circuit breaker configurations for common scenarios.
            These presets represent different approaches to failure tolerance and recovery timing,
            each optimized for specific types of services and failure patterns.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitBreakerPreset.Sensitive">
            <summary>
            Highly sensitive circuit breaker that trips quickly and recovers fast.
            Best for: Critical services where even small failure rates are unacceptable,
            user-facing operations where fast failure detection is important.
            Configuration: 30% failure threshold, 30s sampling, 15s break duration
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitBreakerPreset.Balanced">
            <summary>
            Balanced circuit breaker with moderate thresholds and timing.
            Best for: General-purpose services, internal APIs, most business operations.
            This is the recommended starting point for most applications.
            Configuration: 50% failure threshold, 60s sampling, 30s break duration
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitBreakerPreset.Resilient">
            <summary>
            Resilient circuit breaker that tolerates higher failure rates before tripping.
            Best for: Non-critical services, batch operations, services with expected intermittent failures,
            background processing where availability is less critical than avoiding false positives.
            Configuration: 70% failure threshold, 2min sampling, 1min break duration
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitBreakerPreset.Database">
            <summary>
            Optimized for database operations with conservative failure handling.
            Best for: Entity Framework operations, repository patterns, direct database calls.
            Excludes business logic exceptions from failure counting.
            Configuration: 40% failure threshold, 1min sampling, 45s break duration
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitBreakerPreset.ExternalApi">
            <summary>
            Optimized for external API calls with tolerance for network variability.
            Best for: Third-party API integrations, microservice communication, external dependencies.
            Ignores client errors (4xx) and only counts server errors (5xx) and network issues.
            Configuration: 60% failure threshold, 3min sampling, 60s break duration
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitState">
            <summary>
            Represents the current state of a circuit breaker.
            This enum embodies the finite state machine that protects your services.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitState.Closed">
            <summary>
            Normal operation state. Requests flow through normally, and failures are monitored.
            The circuit remains closed as long as the failure rate stays below the threshold.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitState.Open">
            <summary>
            Protection state. The circuit is open and requests fail immediately without
            hitting the underlying service. This protects both the failing service and your application.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.CircuitBreaker.Models.Enums.CircuitState.HalfOpen">
            <summary>
            Testing state. A limited number of requests are allowed through to test
            if the service has recovered. Based on these test results, the circuit
            either closes (recovery confirmed) or opens again (still failing).
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions">
            <summary>
            Configuration options for circuit breaker behavior.
            Circuit breaker protects your system from cascade failures by temporarily stopping
            requests to failing services, giving them time to recover while preventing resource exhaustion.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions.FailureThresholdPercentage">
            <summary>
            Gets or sets the failure threshold percentage that triggers the circuit to open.
            For example, if set to 50, the circuit opens when 50% or more requests fail
            within the sampling window. Default is 50%.
            Think of this as your "pain tolerance" - how much failure you can accept before protection kicks in.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions.MinimumThroughput">
            <summary>
            Gets or sets the minimum number of requests required in the sampling window before
            the circuit breaker can open. This prevents the circuit from opening due to a small
            number of failures when traffic is low. Default is 5 requests.
            This is your "statistical significance" threshold.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions.SamplingDuration">
            <summary>
            Gets or sets the time window for collecting failure statistics.
            The circuit breaker tracks failures within this rolling window to determine
            if the failure threshold has been exceeded. Default is 60 seconds.
            Think of this as your "memory span" - how far back you look when making decisions.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions.DurationOfBreak">
            <summary>
            Gets or sets how long the circuit stays open before transitioning to half-open state.
            During this time, all requests fail immediately without hitting the underlying service.
            This gives the failing service time to recover. Default is 30 seconds.
            This is your "recovery grace period".
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions.TrialRequestCount">
            <summary>
            Gets or sets the number of trial requests allowed in the half-open state.
            When the circuit is half-open, only this many requests are allowed through
            to test if the service has recovered. Default is 3 requests.
            This is your "recovery test size".
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.CircuitBreakerOptions.ShouldCountAsFailure">
            <summary>
            Gets or sets a function to determine if an exception should be counted as a failure.
            By default, all exceptions are considered failures, but you can customize this
            to ignore certain types of exceptions (like validation errors) that don't indicate
            service health issues.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions">
            <summary>
            Configuration options for streaming circuit breaker behavior.
            
            Circuit breakers for streaming operations need to consider different failure patterns:
            1. Stream-level failures (entire stream fails to start or complete)
            2. Item-level failures (individual items fail processing)
            3. Partial success scenarios (stream yields many items then fails)
            
            This configuration focuses on stream-level circuit breaking, which protects
            downstream services from cascade failures caused by problematic streams.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions.FailureThresholdPercentage">
            <summary>
            Gets or sets the failure threshold percentage for stream operations.
            This represents the percentage of streams that must fail before the circuit opens.
            Default is 60% (higher than regular requests because partial stream success is valuable).
            
            Streams are different from regular requests because even a "failed" stream might
            have yielded valuable data before failing. Consider this when setting thresholds.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions.MinimumThroughput">
            <summary>
            Gets or sets the minimum number of stream attempts required before the circuit can open.
            This prevents the circuit from opening due to a small number of failures when traffic is low.
            Default is 3 streams.
            
            This is typically lower than regular requests because streams are often less frequent
            but more expensive operations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions.SamplingDuration">
            <summary>
            Gets or sets the time window for collecting stream failure statistics.
            The circuit breaker tracks failures within this rolling window.
            Default is 5 minutes (longer than regular requests because streams run longer).
            
            Streaming operations typically have longer lifecycles than regular requests,
            so we need a longer observation window to make meaningful decisions.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions.DurationOfBreak">
            <summary>
            Gets or sets how long the circuit stays open before testing recovery.
            During this time, all stream requests fail immediately without attempting execution.
            Default is 2 minutes (longer recovery time for stream operations).
            
            Streaming failures often indicate deeper system issues (database problems,
            network partitions) that take longer to resolve than typical request failures.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions.TrialRequestCount">
            <summary>
            Gets or sets the number of trial streams allowed in the half-open state.
            When testing recovery, only this many streams are allowed through.
            Default is 2 streams.
            
            Fewer trial streams for testing because each stream might be expensive to execute.
            We want to test recovery without overwhelming a potentially still-fragile system.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions.PartialSuccessThreshold">
            <summary>
            Gets or sets the minimum number of items a stream must yield to be considered partially successful.
            Streams that yield at least this many items before failing might be treated as partial successes.
            Default is 0 (disabled - all failures are treated equally).
            
            Set this to a meaningful number for your use case. For example, if you're processing
            user records and yielding at least 1000 users is valuable even if the stream later fails,
            set this to 1000.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions.ShouldCountAsFailure">
            <summary>
            Gets or sets a function to determine if an exception should be counted as a circuit breaker failure.
            This allows you to distinguish between different types of failures.
            
            Default behavior counts all exceptions as failures, but you might want to exclude
            business logic exceptions or validation errors that don't indicate system health issues.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.CircuitBreaker.Models.Streaming.StreamingCircuitBreakerState">
            <summary>
            Manages circuit breaker state specifically for streaming operations.
            This is similar to the regular CircuitBreakerState but adapted for streaming semantics.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.CircuitBreaker.Models.Streaming.StreamingCircuitBreakerState.#ctor(FS.Mediator.Features.CircuitBreaker.Models.Options.StreamingCircuitBreakerOptions)">
            <summary>
            Manages circuit breaker state specifically for streaming operations.
            This is similar to the regular CircuitBreakerState but adapted for streaming semantics.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior`2">
            <summary>
            Comprehensive health check and diagnostics behavior for streaming operations.
            
            This behavior implements a sophisticated health monitoring system that tracks
            multiple aspects of stream performance and health. It's designed to be non-intrusive
            while providing deep insights into stream behavior.
            
            Key capabilities:
            - Real-time performance monitoring (throughput, latency)
            - Resource usage tracking (memory, GC pressure)
            - Health status assessment with configurable thresholds
            - Integration with monitoring systems through IStreamHealthReporter
            - Detailed diagnostic information collection
            
            The behavior uses the channel-based pattern to ensure all health checking
            logic is separated from the yielding operations, preventing any interference
            with the stream's performance.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior{`0,`1}},FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions,FS.Mediator.Features.HealthChecking.Services.IStreamHealthReporter)">
            <summary>
            Comprehensive health check and diagnostics behavior for streaming operations.
            
            This behavior implements a sophisticated health monitoring system that tracks
            multiple aspects of stream performance and health. It's designed to be non-intrusive
            while providing deep insights into stream behavior.
            
            Key capabilities:
            - Real-time performance monitoring (throughput, latency)
            - Resource usage tracking (memory, GC pressure)
            - Health status assessment with configurable thresholds
            - Integration with monitoring systems through IStreamHealthReporter
            - Detailed diagnostic information collection
            
            The behavior uses the channel-based pattern to ensure all health checking
            logic is separated from the yielding operations, preventing any interference
            with the stream's performance.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior`2.PerformHealthCheckAsync(FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics,System.Threading.CancellationToken)">
            <summary>
            Performs a comprehensive health assessment of the current stream.
            This method evaluates all health metrics and triggers appropriate actions
            based on the findings.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior`2.HandleMemoryPressureAsync(FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics)">
            <summary>
            Handles memory pressure situations by triggering garbage collection if needed.
            This is an optional feature that can help with memory-intensive streaming operations.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior`2.PerformFinalHealthReportAsync(FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics,System.Threading.CancellationToken)">
            <summary>
            Performs final health reporting when the stream completes.
            This provides a comprehensive summary of the stream's health throughout its lifetime.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior`2.IsCriticalWarning(FS.Mediator.Features.HealthChecking.Models.HealthWarning)">
            <summary>
            Determines whether a health warning is critical and requires immediate attention.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Behaviors.Streaming.Diagnostics.HealthCheckBehavior`2.LogDetailedMemoryStatsAsync(FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics)">
            <summary>
            Logs detailed memory statistics for troubleshooting purposes.
            This provides deep insights into memory usage patterns.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Models.Enums.HealthCheckPreset">
            <summary>
            Predefined health check configurations optimized for common streaming scenarios.
            
            These presets represent battle-tested configurations that have been optimized
            for different types of streaming operations. Each preset balances monitoring
            comprehensiveness with performance impact, providing sensible defaults for
            specific use cases.
            
            Think of these as "doctor visit types" - just like you'd have different
            check-up procedures for a routine physical vs. monitoring a critical patient,
            different streaming scenarios need different monitoring approaches.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.HealthCheckPreset.HighPerformance">
            <summary>
            Optimized for high-performance, real-time streaming operations.
            
            Best for: Financial trading systems, real-time analytics, live data feeds
            
            Characteristics:
            - Very frequent health checks (every 5 seconds)
            - Quick stall detection (10 seconds)
            - High throughput expectations (1000+ items/second)
            - Aggressive memory management
            - Very low error tolerance (1%)
            
            Trade-offs: Higher monitoring overhead but maximum responsiveness to issues
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.HealthCheckPreset.DataProcessing">
            <summary>
            Optimized for batch data processing operations like ETL, data migration, and bulk imports.
            
            Best for: Data warehouse ETL, database migrations, bulk data transformations
            
            Characteristics:
            - Moderate health check frequency (every 30 seconds)
            - Longer stall tolerance (2 minutes) for complex processing
            - Moderate throughput expectations (50+ items/second)
            - Larger memory growth tolerance for data-intensive operations
            - Moderate error tolerance (5%) for data quality issues
            - Detailed memory statistics for optimization
            
            Trade-offs: Balanced monitoring that doesn't interfere with data processing
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.HealthCheckPreset.LongRunning">
            <summary>
            Optimized for long-running, overnight batch jobs and maintenance operations.
            
            Best for: Nightly reports, backup operations, system maintenance tasks
            
            Characteristics:
            - Infrequent health checks (every minute) for minimal overhead
            - Long stall tolerance (5 minutes) for complex operations
            - Low throughput expectations (10+ items/second)
            - Large memory growth tolerance for long operations
            - Higher error tolerance (10%) for non-critical operations
            - Comprehensive diagnostics for post-analysis
            
            Trade-offs: Minimal performance impact but slower issue detection
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.HealthCheckPreset.RealTime">
            <summary>
            Optimized for real-time, user-facing streaming operations.
            
            Best for: Live dashboards, streaming APIs, user notifications, chat systems
            
            Characteristics:
            - Very frequent health checks (every 2 seconds)
            - Immediate stall detection (5 seconds)
            - Consistent throughput expectations (100+ items/second)
            - Very low memory tolerance for responsive UX
            - Extremely low error tolerance (0.1%) for user experience
            - Proactive memory management
            
            Trade-offs: Higher overhead but essential for user-facing reliability
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.HealthCheckPreset.Development">
            <summary>
            Optimized for development, testing, and debugging scenarios.
            
            Best for: Local development, integration testing, debugging streaming issues
            
            Characteristics:
            - Moderate health check frequency (every 10 seconds)
            - Reasonable stall detection (30 seconds)
            - Very low throughput requirements (1+ items/second)
            - High error tolerance (20%) for testing error scenarios
            - Comprehensive diagnostics for debugging
            - Predictable behavior for testing
            
            Trade-offs: Prioritizes debugging capability over performance optimization
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Models.Enums.HealthWarningType">
            <summary>
            Types of health warnings that can be detected during streaming operations.
            Each type represents a different category of potential issue.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Models.Enums.StreamHealthStatus">
            <summary>
            Represents the overall health status of a streaming operation.
            This provides a simple "traffic light" system for quickly understanding stream health.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.StreamHealthStatus.Healthy">
            <summary>
            Stream is operating normally with no significant issues detected.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.StreamHealthStatus.Warning">
            <summary>
            Stream is functional but some concerning metrics have been detected.
            The stream can continue operating but should be monitored closely.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.StreamHealthStatus.Unhealthy">
            <summary>
            Stream has significant issues that may impact its ability to function properly.
            Immediate attention may be required.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.HealthChecking.Models.Enums.StreamHealthStatus.Failed">
            <summary>
            Stream has failed and is no longer processing items.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Models.HealthWarning">
            <summary>
            Represents a specific health warning detected during stream processing.
            This provides detailed information about what issue was detected and when.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions">
            <summary>
            Configuration options for the health check behavior.
            These settings control how aggressively the health checking system monitors
            the stream and what thresholds trigger warnings.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions.HealthCheckIntervalSeconds">
            <summary>
            How often to perform comprehensive health assessments (in seconds).
            More frequent checks provide better responsiveness but use more CPU.
            Default: 10 seconds - a good balance for most scenarios.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions.StallDetectionThresholdSeconds">
            <summary>
            Maximum time without new items before considering the stream stalled (in seconds).
            This should be set based on your expected stream characteristics.
            Default: 30 seconds - appropriate for most data processing scenarios.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions.MemoryGrowthThresholdBytes">
            <summary>
            Maximum memory growth (in bytes) before triggering a warning.
            This helps detect memory leaks in long-running streams.
            Default: 100MB - appropriate for most applications.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions.MinimumThroughputItemsPerSecond">
            <summary>
            Minimum expected throughput (items per second) after initial startup.
            Streams performing below this rate will trigger performance warnings.
            Default: 1.0 items/second - adjust based on your performance expectations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions.MaximumErrorRate">
            <summary>
            Maximum acceptable error rate (0.0 to 1.0) before triggering warnings.
            Default: 0.1 (10%) - adjust based on your quality requirements.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions.AutoTriggerGarbageCollection">
            <summary>
            Whether to automatically trigger garbage collection when memory usage is high.
            This can help with memory pressure but may impact performance.
            Default: false - let the GC handle its own timing.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.Options.HealthCheckBehaviorOptions.IncludeDetailedMemoryStats">
            <summary>
            Whether to include detailed memory statistics in health reports.
            This provides more diagnostic information but uses additional resources.
            Default: false - only enable for troubleshooting scenarios.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics">
            <summary>
            Comprehensive health metrics for streaming operations.
            
            This class captures the essential health indicators that help us understand
            whether a streaming operation is functioning properly. Think of it as the
            "vital signs" of your stream - like checking pulse, blood pressure, and
            temperature for a patient.
            
            The metrics are designed to be collected in real-time without impacting
            performance, and they provide actionable insights for troubleshooting.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.StreamStartTime">
            <summary>
            When the stream started processing. This is our baseline for all time-based calculations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.FirstItemTime">
            <summary>
            When the first item was produced by the stream. The difference between StreamStartTime
            and this value tells us about "startup latency" - how long it takes for the stream
            to actually start producing data.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.LastItemTime">
            <summary>
            When the most recent item was produced. This helps us detect "stalls" - situations
            where the stream was producing data but then stopped for an unusually long time.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.TotalItems">
            <summary>
            Total number of items successfully processed by the stream.
            This is our primary throughput indicator.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.CurrentThroughput">
            <summary>
            Current rate of item processing (items per second).
            This is calculated as a rolling average to smooth out short-term fluctuations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.PeakThroughput">
            <summary>
            Peak throughput achieved during this stream's lifetime.
            This helps us understand the stream's best-case performance.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.StartMemoryUsage">
            <summary>
            Memory usage when the stream started (in bytes).
            This baseline helps us detect memory leaks in long-running streams.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.CurrentMemoryUsage">
            <summary>
            Current memory usage (in bytes).
            Significant growth from StartMemoryUsage might indicate a memory leak.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.PeakMemoryUsage">
            <summary>
            Maximum memory usage observed during stream processing.
            This helps us understand the memory footprint of our streaming operations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.GarbageCollectionCount">
            <summary>
            Number of garbage collections that occurred during stream processing.
            Frequent GC can indicate memory pressure and performance issues.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.HealthStatus">
            <summary>
            Overall health status of the stream based on various indicators.
            This provides a quick "traffic light" view of stream health.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.HealthWarnings">
            <summary>
            Collection of health warnings that have been detected.
            Each warning includes details about what was detected and when.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.ErrorCount">
            <summary>
            Number of errors encountered during stream processing.
            This includes both recoverable and non-recoverable errors.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.TimeSinceLastItem">
            <summary>
            Time since the last item was produced. This helps detect stalled streams.
            A high value might indicate the stream has stopped producing data.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.CorrelationId">
            <summary>
            Unique identifier for correlating this stream across different monitoring systems.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.RequestTypeName">
            <summary>
            Type name of the request being processed. This helps group metrics by operation type.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.CustomProperties">
            <summary>
            Custom properties that can be added by specific behaviors or handlers.
            This provides extensibility for domain-specific metrics.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.RecordItemProcessed">
            <summary>
            Records that a new item was successfully processed.
            This method updates all relevant metrics and performs health assessments.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.RecordError(System.Exception)">
            <summary>
            Records that an error occurred during stream processing.
            This method also triggers health status reassessment.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.AssessHealthStatus">
            <summary>
            Evaluates the current health status based on various metrics.
            This is the "brain" of our health checking system - it looks at all
            the metrics we've collected and makes an overall health determination.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics.CalculateCurrentThroughput">
            <summary>
            Calculates the current throughput as a rolling average.
            This provides a smoothed view of performance that isn't affected by
            short-term fluctuations in processing speed.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Services.IStreamHealthReporter">
            <summary>
            Interface for health reporting services.
            This abstraction allows different implementations for various monitoring systems
            (Application Insights, Prometheus, custom dashboards, etc.).
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Services.IStreamHealthReporter.ReportHealthAsync(FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics,System.Threading.CancellationToken)">
            <summary>
            Reports current health metrics to the monitoring system.
            This method should be lightweight and non-blocking to avoid impacting stream performance.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Services.IStreamHealthReporter.ReportCriticalIssueAsync(FS.Mediator.Features.HealthChecking.Models.StreamHealthMetrics,FS.Mediator.Features.HealthChecking.Models.HealthWarning,System.Threading.CancellationToken)">
            <summary>
            Reports a critical health issue that requires immediate attention.
            This might trigger alerts, notifications, or automatic remediation actions.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.HealthChecking.Services.LoggingHealthReporter">
            <summary>
            Default implementation of health reporter that logs health information.
            This provides basic health reporting functionality that works out-of-the-box
            with standard .NET logging infrastructure.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.HealthChecking.Services.LoggingHealthReporter.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.HealthChecking.Services.LoggingHealthReporter})">
            <summary>
            Default implementation of health reporter that logs health information.
            This provides basic health reporting functionality that works out-of-the-box
            with standard .NET logging infrastructure.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Logging.Behaviors.LoggingBehavior`2">
            <summary>
            Pipeline behavior that provides logging for request processing.
            Logs the request type, execution time, and any exceptions that occur.
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Logging.Behaviors.LoggingBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.Logging.Behaviors.LoggingBehavior{`0,`1}})">
            <summary>
            Pipeline behavior that provides logging for request processing.
            Logs the request type, execution time, and any exceptions that occur.
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Logging.Behaviors.LoggingBehavior`2.HandleAsync(`0,FS.Mediator.Features.RequestHandling.Core.RequestHandlerDelegate{`1},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:FS.Mediator.Features.Logging.Behaviors.Streaming.StreamingLoggingBehavior`2">
            <summary>
            Streaming pipeline behavior that provides comprehensive logging for stream operations.
            
            This implementation uses a Channel-based pattern to completely separate error handling
            from yielding operations. The key insight is that we process the stream in a background
            task (where we can use try-catch), and then yield items from a channel (no try-catch needed).
            
            This approach ensures we never have yield return statements inside try-catch blocks,
            which is a fundamental C# language constraint.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Logging.Behaviors.Streaming.StreamingLoggingBehavior`2.ShouldLogProgress(System.Int64,System.DateTime,System.DateTime)">
            <summary>
            Determines whether progress should be logged based on configured intervals.
            This prevents log spam while ensuring visibility into long-running operations.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Logging.Models.Options.StreamingLoggingOptions">
            <summary>
            Configuration options for streaming logging behavior.
            
            Streaming operations can produce thousands or millions of items, so logging
            every single item would overwhelm your logs and degrade performance.
            These options help you find the right balance between visibility and performance.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Logging.Models.Options.StreamingLoggingOptions.LogProgressEveryNItems">
            <summary>
            Gets or sets how often to log progress based on item count.
            For example, setting this to 1000 will log progress every 1000 items.
            Set to 0 to disable item-count-based progress logging.
            Default is 1000 items.
            
            Use lower values (100-500) for debugging, higher values (5000-10000) for production.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Logging.Models.Options.StreamingLoggingOptions.LogProgressEveryNSeconds">
            <summary>
            Gets or sets how often to log progress based on time intervals (in seconds).
            For example, setting this to 30 will log progress every 30 seconds regardless of item count.
            Set to 0 to disable time-based progress logging.
            Default is 30 seconds.
            
            This is crucial for slow streams that might not hit the item count threshold quickly.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Logging.Models.Options.StreamingLoggingOptions.LogDetailedMetrics">
            <summary>
            Gets or sets whether to log detailed performance metrics at stream completion.
            This includes items per second, total duration, and memory usage patterns.
            Default is true.
            
            Disable this in high-frequency scenarios where the logging overhead becomes significant.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.NotificationHandling.Core.INotification">
            <summary>
            Marker interface for notifications that can be published through the mediator.
            Implement this interface to create notification objects that can be handled by multiple handlers.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.NotificationHandling.Core.INotificationHandler`1">
            <summary>
            Defines a handler for a notification of type TNotification.
            Multiple handlers can exist for the same notification type.
            </summary>
            <typeparam name="TNotification">The type of notification being handled.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.NotificationHandling.Core.INotificationHandler`1.HandleAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Handles the specified notification asynchronously.
            </summary>
            <param name="notification">The notification to handle.</param>
            <param name="cancellationToken">A cancellation token to cancel the operation.</param>
            <returns>A task representing the asynchronous operation.</returns>
        </member>
        <member name="T:FS.Mediator.Features.Performance.Behaviors.PerformanceBehavior`2">
            <summary>
            Pipeline behavior that monitors request performance and logs slow-running requests.
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Performance.Behaviors.PerformanceBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.Performance.Behaviors.PerformanceBehavior{`0,`1}},FS.Mediator.Features.Performance.Models.Options.PerformanceBehaviorOptions)">
            <summary>
            Pipeline behavior that monitors request performance and logs slow-running requests.
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Performance.Behaviors.PerformanceBehavior`2.HandleAsync(`0,FS.Mediator.Features.RequestHandling.Core.RequestHandlerDelegate{`1},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:FS.Mediator.Features.Performance.Behaviors.Streaming.StreamingPerformanceBehavior`2">
            <summary>
            Streaming pipeline behavior that monitors performance and logs slow streams.
            
            Performance monitoring for streams focuses on throughput (items/second), time to first item,
            and total duration. This implementation uses the channel pattern to separate performance
            monitoring logic from the yielding operations.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="T:FS.Mediator.Features.Performance.Models.Options.PerformanceBehaviorOptions">
            <summary>
            Configuration options for the PerformanceBehavior.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Performance.Models.Options.PerformanceBehaviorOptions.WarningThresholdMs">
            <summary>
            Gets or sets the warning threshold in milliseconds for logging performance warnings.
            Default is 500ms.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Performance.Models.Options.StreamingPerformanceOptions">
            <summary>
            Configuration options for streaming performance monitoring behavior.
            
            Performance monitoring for streams requires different metrics than regular requests:
            - Throughput (items per second) instead of just response time
            - Time to first item (latency) separate from total duration
            - Progress tracking for long-running operations
            
            These options help you identify performance bottlenecks in streaming scenarios.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Performance.Models.Options.StreamingPerformanceOptions.TimeToFirstItemWarningMs">
            <summary>
            Gets or sets the warning threshold for time to first item (in milliseconds).
            This measures how long it takes for a stream to yield its first item after being started.
            Default is 5000ms (5 seconds).
            
            This is crucial for user experience - even if the total stream takes a long time,
            users expect to see the first results quickly. High time-to-first-item often
            indicates initialization problems (slow database queries, network delays, etc.).
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Performance.Models.Options.StreamingPerformanceOptions.MinimumThroughputItemsPerSecond">
            <summary>
            Gets or sets the minimum expected throughput in items per second.
            Streams that consistently produce fewer items per second trigger performance warnings.
            Default is 10 items per second.
            
            Set this based on your specific use case:
            - Database query streams might target 100-1000 items/sec
            - API aggregation streams might target 10-50 items/sec  
            - File processing streams might target 500-5000 items/sec
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Performance.Models.Options.StreamingPerformanceOptions.ThroughputCheckIntervalSeconds">
            <summary>
            Gets or sets how often to check throughput performance (in seconds).
            The behavior will calculate and check throughput at these intervals.
            Default is 30 seconds.
            
            More frequent checks (10-15 seconds) provide faster feedback but generate more logs.
            Less frequent checks (60-120 seconds) reduce overhead but might miss short-term performance issues.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Performance.Models.Options.StreamingPerformanceOptions.TotalDurationWarningMs">
            <summary>
            Gets or sets the warning threshold for total stream duration (in milliseconds).
            Streams that run longer than this threshold trigger performance warnings.
            Default is 300,000ms (5 minutes).
            
            This helps identify streams that are taking unexpectedly long to complete.
            Set this based on your business requirements and user expectations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Performance.Models.Options.StreamingPerformanceOptions.CollectMemoryMetrics">
            <summary>
            Gets or sets whether to collect detailed memory usage metrics during streaming.
            This can help identify memory leaks or excessive memory usage in stream processing.
            Default is false (disabled due to performance overhead).
            
            Enable this only when investigating specific performance issues, as it adds
            measurement overhead to every stream operation.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.IMediator">
            <summary>
            Defines the mediator interface for sending requests and publishing notifications.
            This is the main entry point for all request/response and notification operations.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IMediator.SendAsync``1(FS.Mediator.Features.RequestHandling.Core.IRequest{``0},System.Threading.CancellationToken)">
            <summary>
            Sends a request and returns the response asynchronously.
            </summary>
            <typeparam name="TResponse">The type of response expected from the request.</typeparam>
            <param name="request">The request to send.</param>
            <param name="cancellationToken">A cancellation token to cancel the operation.</param>
            <returns>A task representing the asynchronous operation that returns the response.</returns>
            <exception cref="T:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException">Thrown when no handler is found for the request type.</exception>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IMediator.SendAsync(FS.Mediator.Features.RequestHandling.Core.IRequest{FS.Mediator.Features.RequestHandling.Core.Unit},System.Threading.CancellationToken)">
            <summary>
            Sends a request that doesn't return a specific value (returns Unit) asynchronously.
            </summary>
            <param name="request">The request to send.</param>
            <param name="cancellationToken">A cancellation token to cancel the operation.</param>
            <returns>A task representing the asynchronous operation.</returns>
            <exception cref="T:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException">Thrown when no handler is found for the request type.</exception>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IMediator.CreateStream``1(FS.Mediator.Features.StreamHandling.Core.IStreamRequest{``0},System.Threading.CancellationToken)">
            <summary>
            Creates a data stream from a streaming request and returns results as they become available.
            This is perfect for scenarios where you need to process large amounts of data efficiently:
            
            Example use cases:
            - Processing millions of database records without loading them all into memory
            - Reading large files and yielding processed lines incrementally
            - Creating real-time data feeds that continuously produce results
            - Building APIs that can start returning data before all processing is complete
            
            The key benefit is that your application can start processing and displaying results
            immediately as they become available, rather than waiting for everything to complete.
            </summary>
            <typeparam name="TResponse">The type of each item in the stream.</typeparam>
            <param name="request">The streaming request to process.</param>
            <param name="cancellationToken">A cancellation token to cancel the streaming operation.</param>
            <returns>An async enumerable that yields results as they become available.</returns>
            <exception cref="T:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException">Thrown when no handler is found for the request type.</exception>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IMediator.CreateStream(System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates a data stream from a streaming request and returns results as they become available.
            This is perfect for scenarios where you need to process large amounts of data efficiently:
            
            Example use cases:
            - Processing millions of database records without loading them all into memory
            - Reading large files and yielding processed lines incrementally
            - Creating real-time data feeds that continuously produce results
            - Building APIs that can start returning data before all processing is complete
            
            The key benefit is that your application can start processing and displaying results
            immediately as they become available, rather than waiting for everything to complete.
            </summary>
            <param name="request">The streaming request to process.</param>
            <param name="cancellationToken">A cancellation token to cancel the streaming operation.</param>
            <returns>An async enumerable that yields results as they become available.</returns>
            <exception cref="T:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException">Thrown when no handler is found for the request type.</exception>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IMediator.PublishAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            Publishes a notification to all registered handlers asynchronously.
            </summary>
            <typeparam name="TNotification">The type of notification to publish.</typeparam>
            <param name="notification">The notification to publish.</param>
            <param name="cancellationToken">A cancellation token to cancel the operation.</param>
            <returns>A task representing the asynchronous operation.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.RequestHandlerDelegate`1">
            <summary>
            Represents a request handler delegate for pipeline behaviors.
            </summary>
            <typeparam name="TResponse">The type of response returned by the handler.</typeparam>
            <returns>A task representing the asynchronous operation that returns the response.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.IPipelineBehavior`2">
            <summary>
            Defines a pipeline behavior that can be applied to requests before they reach their handlers.
            Pipeline behaviors are executed in the order they are registered and can perform cross-cutting concerns
            such as logging, validation, caching, or exception handling.
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IPipelineBehavior`2.HandleAsync(`0,FS.Mediator.Features.RequestHandling.Core.RequestHandlerDelegate{`1},System.Threading.CancellationToken)">
            <summary>
            Handles the request within the pipeline.
            </summary>
            <param name="request">The request being processed.</param>
            <param name="next">The next handler in the pipeline.</param>
            <param name="cancellationToken">A cancellation token to cancel the operation.</param>
            <returns>A task representing the asynchronous operation that returns the response.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.IBaseRequest">
            <summary>
            Allows for generic type constraints of objects implementing IRequest or IRequest{TResponse}
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.IRequest">
            <summary>
            Marker interface for requests that return a response of type Unit.
            Implement this interface to create request objects that can be handled by the mediator.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.IRequest`1">
            <summary>
            Marker interface for requests that return a response of type TResponse.
            Implement this interface to create request objects that can be handled by the mediator.
            </summary>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.IRequestHandler`1">
            <summary>
            Defines a handler for a request of type TRequest.
            Implement this interface to create handlers that process specific request types.
            </summary>
            <typeparam name="TRequest">The type of request being handled.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IRequestHandler`1.HandleAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Handles the specified request asynchronously.
            </summary>
            <param name="request">The request to handle.</param>
            <param name="cancellationToken">A cancellation token to cancel the operation.</param>
            <returns>A task representing the asynchronous operation.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.IRequestHandler`2">
            <summary>
            Defines a handler for a request of type TRequest that returns a response of type TResponse.
            Implement this interface to create handlers that process specific request types.
            </summary>
            <typeparam name="TRequest">The type of request being handled.</typeparam>
            <typeparam name="TResponse">The type of response returned by the handler.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.IRequestHandler`2.HandleAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Handles the specified request asynchronously.
            </summary>
            <param name="request">The request to handle.</param>
            <param name="cancellationToken">A cancellation token to cancel the operation.</param>
            <returns>A task representing the asynchronous operation that returns the response.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Core.Unit">
            <summary>
            Represents a unit type for operations that don't return a value.
            This is used as the response type for requests that only perform actions without returning data.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.RequestHandling.Core.Unit.Value">
            <summary>
            Gets the singleton instance of the Unit type.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.Unit.Equals(FS.Mediator.Features.RequestHandling.Core.Unit)">
            <summary>
            Determines whether the specified Unit is equal to the current Unit.
            </summary>
            <param name="other">The Unit to compare with the current Unit.</param>
            <returns>Always returns true since all Unit instances are considered equal.</returns>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.Unit.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current Unit.
            </summary>
            <param name="obj">The object to compare with the current Unit.</param>
            <returns>True if the specified object is a Unit; otherwise, false.</returns>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.Unit.GetHashCode">
            <summary>
            Returns the hash code for this Unit.
            </summary>
            <returns>Always returns 0 since all Unit instances are considered equal.</returns>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.Unit.op_Equality(FS.Mediator.Features.RequestHandling.Core.Unit,FS.Mediator.Features.RequestHandling.Core.Unit)">
            <summary>
            Determines whether two Unit instances are equal.
            </summary>
            <param name="left">The first Unit to compare.</param>
            <param name="right">The second Unit to compare.</param>
            <returns>Always returns true since all Unit instances are considered equal.</returns>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.Unit.op_Inequality(FS.Mediator.Features.RequestHandling.Core.Unit,FS.Mediator.Features.RequestHandling.Core.Unit)">
            <summary>
            Determines whether two Unit instances are not equal.
            </summary>
            <param name="left">The first Unit to compare.</param>
            <param name="right">The second Unit to compare.</param>
            <returns>Always returns false since all Unit instances are considered equal.</returns>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Core.Unit.ToString">
            <summary>
            Returns a string representation of the Unit.
            </summary>
            <returns>The string "()" representing an empty tuple.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException">
            <summary>
            Exception thrown when no handler is found for a specific request or notification type.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the HandlerNotFoundException class.
            </summary>
            <param name="handlerType">The type of handler that was not found.</param>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException.#ctor(System.String,System.Type)">
            <summary>
            Initializes a new instance of the HandlerNotFoundException class with a custom message.
            </summary>
            <param name="message">The custom error message.</param>
            <param name="handlerType">The type of handler that was not found.</param>
        </member>
        <member name="P:FS.Mediator.Features.RequestHandling.Exceptions.HandlerNotFoundException.HandlerType">
            <summary>
            Gets the type of handler that was not found.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Implementation.Mediator">
            <summary>
            Enhanced implementation of the IMediator interface with interceptor support.
            This implementation provides a sophisticated request processing pipeline that includes:
            
            1. Request Interception: Transforms or validates requests before processing
            2. Pipeline Behaviors: Cross-cutting concerns like logging, retry, circuit breaking
            3. Handler Execution: The actual business logic processing
            4. Response Interception: Transforms or enriches responses before returning
            
            This layered approach provides maximum flexibility while maintaining clean separation of concerns.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.#ctor(FS.Mediator.Features.RequestHandling.Implementation.ServiceFactory,FS.Mediator.Features.RequestHandling.Implementation.ServiceFactoryCollection)">
            <summary>
            Enhanced implementation of the IMediator interface with interceptor support.
            This implementation provides a sophisticated request processing pipeline that includes:
            
            1. Request Interception: Transforms or validates requests before processing
            2. Pipeline Behaviors: Cross-cutting concerns like logging, retry, circuit breaking
            3. Handler Execution: The actual business logic processing
            4. Response Interception: Transforms or enriches responses before returning
            
            This layered approach provides maximum flexibility while maintaining clean separation of concerns.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.SendAsync``1(FS.Mediator.Features.RequestHandling.Core.IRequest{``0},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.SendAsync(FS.Mediator.Features.RequestHandling.Core.IRequest{FS.Mediator.Features.RequestHandling.Core.Unit},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.CreateStream``1(FS.Mediator.Features.StreamHandling.Core.IStreamRequest{``0},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.CreateStream(System.Object,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.PublishAsync``1(``0,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.ExecuteRequestInterceptorsAsync``2(``0,System.Threading.CancellationToken)">
            <summary>
            Executes all registered request interceptors for the given request.
            This method provides a powerful extension point for request transformation and validation.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.ExecutePipelineAsync``1(FS.Mediator.Features.RequestHandling.Core.IRequest{``0},System.Object,System.Type,System.Threading.CancellationToken)">
            <summary>
            Executes the main processing pipeline including all registered behaviors.
            This is where the core mediator pattern happens, with cross-cutting concerns applied.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.ExecuteResponseInterceptorsAsync``2(``0,``1,System.Threading.CancellationToken)">
            <summary>
            Executes all registered response interceptors for the given response.
            This method provides the final opportunity to transform or enrich responses.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Implementation.Mediator.ExecuteStreamingPipelineAsync``1(FS.Mediator.Features.StreamHandling.Core.IStreamRequest{``0},System.Object,System.Type,System.Threading.CancellationToken)">
            <summary>
            Executes the streaming processing pipeline including all registered streaming behaviors.
            This is the heart of streaming operations - where cross-cutting concerns like logging,
            retry logic, and circuit breaking are applied to continuous data flows.
            
            The key insight here is that streaming behaviors work fundamentally differently
            from regular behaviors because they operate on IAsyncEnumerable rather than single values.
            Each behavior in the chain can transform, filter, or enrich the stream of data
            as it flows through the pipeline.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Implementation.ServiceFactory">
            <summary>
            Factory delegate for creating service instances.
            </summary>
            <param name="serviceType">The type of service to create.</param>
            <returns>An instance of the requested service type.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Implementation.ServiceFactoryCollection">
            <summary>
            Factory delegate for creating multiple service instances.
            </summary>
            <param name="serviceType">The type of services to create.</param>
            <returns>A collection of instances of the requested service type.</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Interceptors.IGlobalRequestInterceptor">
            <summary>
            Defines a global request interceptor that can inspect and potentially modify any request
            regardless of its type. This is useful for implementing cross-cutting concerns that apply
            to all requests in your system, such as:
            
            - Global security checks
            - Universal audit logging
            - System-wide correlation ID injection
            - Global request validation rules
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Interceptors.IGlobalRequestInterceptor.InterceptRequestAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            Intercepts any request before it enters the pipeline.
            This method receives requests as objects, so you'll need to use pattern matching
            or reflection if you need to perform type-specific operations.
            </summary>
            <param name="request">The request to intercept (any type implementing IBaseRequest)</param>
            <param name="cancellationToken">Cancellation token for the operation</param>
            <returns>The request to pass to the pipeline (may be the original or a transformed version)</returns>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Interceptors.IGlobalRequestInterceptor.ShouldIntercept(System.Type)">
            <summary>
            Determines whether this interceptor should handle the given request type.
            This allows global interceptors to selectively process only certain types of requests.
            </summary>
            <param name="requestType">The type of the request being processed</param>
            <returns>True if this interceptor should process the request, false to skip it</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Interceptors.IGlobalResponseInterceptor">
            <summary>
            Defines a global response interceptor that can inspect and potentially modify any response
            regardless of its type. This is useful for implementing cross-cutting concerns that apply
            to all responses in your system, such as:
            
            - Global response logging and auditing
            - Universal performance metrics collection
            - System-wide response transformation
            - Global caching strategies
            - Security-related response filtering
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Interceptors.IGlobalResponseInterceptor.InterceptResponseAsync(System.Object,System.Object,System.Threading.CancellationToken)">
            <summary>
            Intercepts any response after pipeline processing.
            This method receives both requests and responses as objects, so you'll need to use 
            pattern matching or reflection if you need to perform type-specific operations.
            </summary>
            <param name="request">The original request that generated this response</param>
            <param name="response">The response from the pipeline to intercept</param>
            <param name="cancellationToken">Cancellation token for the operation</param>
            <returns>The response to return to the caller (may be the original or a transformed version)</returns>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Interceptors.IGlobalResponseInterceptor.ShouldIntercept(System.Type,System.Type)">
            <summary>
            Determines whether this interceptor should handle the given request/response types.
            This allows global interceptors to selectively process only certain types of operations.
            </summary>
            <param name="requestType">The type of the request being processed</param>
            <param name="responseType">The type of the response being processed</param>
            <returns>True if this interceptor should process the response, false to skip it</returns>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Interceptors.IRequestInterceptor`2">
            <summary>
            Defines a request interceptor that can inspect and potentially modify requests
            before they enter the mediator pipeline. Request interceptors are executed
            before pipeline behaviors and are perfect for:
            
            - Request validation and sanitization
            - Security checks and authorization
            - Request transformation and mapping
            - Audit logging of incoming requests
            - Adding correlation IDs or tracing information
            
            Unlike pipeline behaviors, interceptors focus specifically on request/response
            transformation rather than cross-cutting concerns like retry logic or circuit breaking.
            </summary>
            <typeparam name="TRequest">The type of request being intercepted</typeparam>
            <typeparam name="TResponse">The type of response expected from the request</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Interceptors.IRequestInterceptor`2.InterceptRequestAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Intercepts and potentially transforms a request before it enters the pipeline.
            This method is called for every request of the specified type and allows you to:
            
            - Validate the request and throw exceptions if invalid
            - Transform or enrich the request with additional data
            - Log or audit the incoming request
            - Perform security checks or authorization
            
            The interceptor can either return the original request unchanged,
            return a modified version of the request, or throw an exception to prevent processing.
            </summary>
            <param name="request">The original request to intercept</param>
            <param name="cancellationToken">Cancellation token for the operation</param>
            <returns>The request to pass to the pipeline (may be the original or a transformed version)</returns>
            <exception cref="T:System.ArgumentException">Thrown when the request is invalid</exception>
            <exception cref="T:System.UnauthorizedAccessException">Thrown when authorization fails</exception>
        </member>
        <member name="T:FS.Mediator.Features.RequestHandling.Interceptors.IResponseInterceptor`2">
            <summary>
            Defines a response interceptor that can inspect and potentially modify responses
            after they're returned from the mediator pipeline but before they reach the caller.
            Response interceptors are perfect for:
            
            - Response transformation and mapping
            - Adding metadata or enriching responses
            - Response validation and sanitization
            - Caching or storing responses
            - Audit logging of outgoing responses
            - Performance metrics collection
            
            Response interceptors execute after all pipeline behaviors have completed successfully,
            giving you the final opportunity to modify or enrich the response data.
            </summary>
            <typeparam name="TRequest">The type of request that generated this response</typeparam>
            <typeparam name="TResponse">The type of response being intercepted</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.RequestHandling.Interceptors.IResponseInterceptor`2.InterceptResponseAsync(`0,`1,System.Threading.CancellationToken)">
            <summary>
            Intercepts and potentially transforms a response after pipeline processing.
            This method is called for every successful response of the specified type and allows you to:
            
            - Transform or enrich the response with additional data
            - Cache the response for future requests
            - Log or audit the outgoing response
            - Add metadata like timestamps or correlation IDs
            - Validate the response before returning it
            
            The interceptor can either return the original response unchanged,
            return a modified version of the response, or throw an exception.
            </summary>
            <param name="request">The original request that generated this response</param>
            <param name="response">The response from the pipeline to intercept</param>
            <param name="cancellationToken">Cancellation token for the operation</param>
            <returns>The response to return to the caller (may be the original or a transformed version)</returns>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2">
            <summary>
            Pipeline behavior that manages system resources during request processing.
            
            Think of this behavior as your application's "resource guardian" - it continuously
            monitors memory usage, tracks disposable resources, and takes corrective action
            when resource pressure builds up. This is particularly crucial in long-running
            applications that process many requests over time.
            
            The behavior operates on several levels:
            1. **Preventive Monitoring**: Continuously tracks resource usage patterns
            2. **Early Warning**: Detects concerning trends before they become problems  
            3. **Active Management**: Takes corrective action when thresholds are exceeded
            4. **Resource Tracking**: Ensures proper cleanup of disposable resources
            
            This is especially valuable in microservice architectures where memory leaks
            can cause cascading failures across the entire system.
            </summary>
            <typeparam name="TRequest">The type of request being processed</typeparam>
            <typeparam name="TResponse">The type of response returned by the request</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior{`0,`1}},FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions)">
            <summary>
            Pipeline behavior that manages system resources during request processing.
            
            Think of this behavior as your application's "resource guardian" - it continuously
            monitors memory usage, tracks disposable resources, and takes corrective action
            when resource pressure builds up. This is particularly crucial in long-running
            applications that process many requests over time.
            
            The behavior operates on several levels:
            1. **Preventive Monitoring**: Continuously tracks resource usage patterns
            2. **Early Warning**: Detects concerning trends before they become problems  
            3. **Active Management**: Takes corrective action when thresholds are exceeded
            4. **Resource Tracking**: Ensures proper cleanup of disposable resources
            
            This is especially valuable in microservice architectures where memory leaks
            can cause cascading failures across the entire system.
            </summary>
            <typeparam name="TRequest">The type of request being processed</typeparam>
            <typeparam name="TResponse">The type of response returned by the request</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.HandleAsync(`0,FS.Mediator.Features.RequestHandling.Core.RequestHandlerDelegate{`1},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.PerformResourceCheckAsync(FS.Mediator.Features.ResourceManagement.Behaviors.ResourceMonitoringSession,System.String)">
            <summary>
            Performs a comprehensive resource check and takes action if thresholds are exceeded.
            This is the heart of our resource management logic.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.HandleResourcePressureAsync(FS.Mediator.Features.ResourceManagement.Behaviors.ResourceMonitoringSession)">
            <summary>
            Handles detected resource pressure by applying the configured cleanup strategy.
            This method escalates through different levels of cleanup based on severity.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.ApplyConservativeCleanupAsync(FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext)">
            <summary>
            Applies conservative cleanup strategy - minimal impact, maximum safety.
            This is like "gentle housekeeping" - we clean up what we can without disrupting operations.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.ApplyBalancedCleanupAsync(FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext)">
            <summary>
            Applies balanced cleanup strategy - moderate impact, good effectiveness.
            This is like "thorough housekeeping" - we clean more aggressively but still maintain performance.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.ApplyAggressiveCleanupAsync(FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext)">
            <summary>
            Applies aggressive cleanup strategy - maximum impact, maximum effectiveness.
            This is like "deep cleaning" - we prioritize memory reclamation over performance.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.CleanupAbandonedDisposablesAsync">
            <summary>
            Cleans up disposable resources that may have been abandoned by request handlers.
            This helps prevent resource leaks from handlers that forget to dispose resources properly.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.PerformGlobalMaintenanceIfNeededAsync">
            <summary>
            Performs global maintenance tasks periodically.
            This ensures system-wide resource health even when individual requests aren't triggering cleanup.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.CleanupSessionAsync(FS.Mediator.Features.ResourceManagement.Behaviors.ResourceMonitoringSession)">
            <summary>
            Cleans up a specific monitoring session and its tracked resources.
            This ensures proper resource cleanup when request processing completes.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.LogDetailedMemoryStatsAsync(FS.Mediator.Features.ResourceManagement.Behaviors.ResourceMonitoringSession)">
            <summary>
            Logs detailed memory statistics for diagnostic purposes.
            This provides deep insights into memory usage patterns for troubleshooting.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceManagementBehavior`2.GetTotalGcCount">
            <summary>
            Gets the total garbage collection count across all generations.
            This provides a single metric for GC activity.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Behaviors.ResourceMonitoringSession">
            <summary>
            Represents a resource monitoring session for a single request.
            This tracks all the metrics and state needed to manage resources for one request's lifecycle.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2">
            <summary>
            Streaming pipeline behavior that manages system resources during stream processing.
            
            Streaming resource management is like being a careful shepherd watching over a flock
            that's constantly moving. Unlike regular requests that have a clear beginning and end,
            streams can run for hours or even days, making resource management absolutely critical.
            
            Think of this behavior as your stream's "resource bodyguard" that:
            1. **Monitors Continuously**: Tracks memory usage as data flows through
            2. **Prevents Accumulation**: Ensures resources don't build up over time
            3. **Responds Proactively**: Takes action before problems become critical
            4. **Maintains Flow**: Keeps the stream healthy without interrupting data flow
            
            This is especially crucial for:
            - Large data processing operations that handle millions of records
            - Real-time data streams that run continuously
            - ETL operations that transform massive datasets
            - Long-running analytics processes
            
            The behavior uses the channel pattern to ensure resource management logic
            is completely separated from the yielding operations, maintaining stream performance.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior{`0,`1}},FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions)">
            <summary>
            Streaming pipeline behavior that manages system resources during stream processing.
            
            Streaming resource management is like being a careful shepherd watching over a flock
            that's constantly moving. Unlike regular requests that have a clear beginning and end,
            streams can run for hours or even days, making resource management absolutely critical.
            
            Think of this behavior as your stream's "resource bodyguard" that:
            1. **Monitors Continuously**: Tracks memory usage as data flows through
            2. **Prevents Accumulation**: Ensures resources don't build up over time
            3. **Responds Proactively**: Takes action before problems become critical
            4. **Maintains Flow**: Keeps the stream healthy without interrupting data flow
            
            This is especially crucial for:
            - Large data processing operations that handle millions of records
            - Real-time data streams that run continuously
            - ETL operations that transform massive datasets
            - Long-running analytics processes
            
            The behavior uses the channel pattern to ensure resource management logic
            is completely separated from the yielding operations, maintaining stream performance.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.PerformPeriodicResourceCheckAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession)">
            <summary>
            Performs periodic resource assessment during stream processing.
            This is like taking the "vital signs" of your stream at regular intervals.
            
            Unlike one-time requests, streams need continuous monitoring because:
            - Memory can accumulate gradually over thousands of items
            - Resource leaks compound over time
            - Performance can degrade slowly without notice
            - Early intervention prevents catastrophic failures
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.CheckMemoryPressureAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession)">
            <summary>
            Checks for immediate memory pressure that requires action.
            This is like checking if your car's engine is overheating - if it is, you need to pull over now.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.DetectResourceTrendsAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession)">
            <summary>
            Detects concerning resource trends that might indicate developing problems.
            This is like a doctor noticing that your blood pressure has been gradually increasing -
            not immediately dangerous, but worth monitoring and potentially addressing.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.HandleStreamingResourcePressureAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession)">
            <summary>
            Handles detected resource pressure using streaming-optimized strategies.
            This is like performing emergency maintenance on a running machine - we need to fix the problem
            without stopping the operation if possible.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.ApplyStreamingConservativeCleanupAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession,FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext)">
            <summary>
            Conservative cleanup optimized for streaming operations.
            This approach prioritizes stream continuity over aggressive memory reclamation.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.ApplyStreamingBalancedCleanupAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession,FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext)">
            <summary>
            Balanced cleanup for streaming that provides good memory reclamation with acceptable latency impact.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.ApplyStreamingAggressiveCleanupAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession,FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext)">
            <summary>
            Aggressive cleanup for streaming when memory pressure is critical.
            This prioritizes memory reclamation and accepts higher latency impact.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.PerformFinalResourceAssessmentAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession)">
            <summary>
            Performs final resource assessment when the stream completes.
            This provides a comprehensive summary of resource usage throughout the stream's lifetime.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.CalculateResourceEfficiencyScore(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession,System.Int64,System.TimeSpan)">
            <summary>
            Calculates a resource efficiency score for the streaming operation.
            This provides a single metric to understand how efficiently resources were used.
            Score ranges from 0 (very inefficient) to 100 (highly efficient).
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.PerformResourceCleanupAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession,System.String)">
            <summary>
            Performs resource cleanup when the stream ends (normally or abnormally).
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.LogDetailedStreamingMemoryStatsAsync(FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession)">
            <summary>
            Logs detailed memory statistics specific to streaming operations.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceManagementBehavior`2.GetTotalGcCount">
            <summary>
            Gets the total garbage collection count across all generations.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Behaviors.Streaming.StreamingResourceSession">
            <summary>
            Represents a resource monitoring session for a streaming operation.
            This tracks all metrics and state needed for resource management throughout a stream's lifecycle.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceCleanupStrategy">
            <summary>
            Defines different strategies for cleaning up resources when thresholds are exceeded.
            Each strategy represents a different balance between aggressiveness and performance impact.
            
            Think of these strategies like different levels of "spring cleaning" in your home:
            - Conservative: Light tidying up, minimal disruption
            - Balanced: Thorough cleaning with manageable effort
            - Aggressive: Deep cleaning that takes time but maximizes results
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceCleanupStrategy.Conservative">
            <summary>
            Minimal cleanup actions that are safe and have low performance impact.
            
            Actions include:
            - Suggest garbage collection (GC.Collect() if AutoTriggerGarbageCollection is true)
            - Clear weak references
            - Log resource pressure warnings
            
            Best for: Production systems where stability is paramount
            Trade-offs: Lowest performance impact but least memory reclamation
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceCleanupStrategy.Balanced">
            <summary>
            Balanced approach with moderate cleanup actions.
            
            Actions include:
            - All Conservative actions
            - Force garbage collection for generations 0 and 1
            - Trim working set if possible
            - Clear finalizer queue
            
            Best for: Most applications where some performance impact is acceptable
            Trade-offs: Good balance between memory reclamation and performance
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceCleanupStrategy.Aggressive">
            <summary>
            Aggressive cleanup actions that prioritize memory reclamation over performance.
            
            Actions include:
            - All Balanced actions
            - Full garbage collection (all generations)
            - Compact large object heap
            - Force disposal of tracked resources
            - Clear thread-local storage
            
            Best for: Memory-constrained environments or batch processing scenarios
            Trade-offs: Maximum memory reclamation but highest performance impact
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset">
            <summary>
            Predefined resource management configurations optimized for common deployment scenarios.
            
            These presets represent different "resource management philosophies" based on your
            deployment environment and performance requirements. Think of them as choosing
            the right tool for the right job.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset.MemoryConstrained">
            <summary>
            Optimized for memory-constrained environments like containers and embedded systems.
            
            This preset is like being a "strict budgeter" with your memory - it monitors
            closely, acts quickly, and prioritizes memory conservation over performance.
            
            Configuration highlights:
            - Low memory thresholds (256MB)
            - Aggressive cleanup strategies
            - Frequent monitoring
            - Automatic garbage collection
            - Full resource tracking
            
            Best for:
            - Docker containers with memory limits
            - Kubernetes pods with resource constraints
            - Embedded systems
            - Shared hosting environments
            - Cost-optimized cloud deployments
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset.HighPerformance">
            <summary>
            Optimized for high-performance applications where latency is critical.
            
            This preset is like being a "performance athlete" - it prioritizes speed
            and consistency over aggressive resource management, trusting that adequate
            resources are available.
            
            Configuration highlights:
            - High memory thresholds (1GB+)
            - Conservative cleanup strategies
            - Infrequent monitoring to reduce overhead
            - Let GC manage itself
            - Minimal resource tracking overhead
            
            Best for:
            - High-frequency trading systems
            - Real-time gaming applications
            - Low-latency APIs
            - Performance-critical microservices
            - Applications with strict SLA requirements
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset.Balanced">
            <summary>
            Balanced configuration suitable for most production applications.
            
            This preset is like being a "sensible homeowner" - it maintains good
            practices without being excessive, providing reliable operation for
            typical business applications.
            
            Configuration highlights:
            - Moderate memory thresholds (512MB)
            - Balanced cleanup strategies
            - Regular monitoring intervals
            - Selective garbage collection
            - Standard resource tracking
            
            Best for:
            - Web applications
            - Business APIs
            - Standard microservices
            - Most enterprise applications
            - General-purpose services
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.ResourceManagement.Models.Enums.ResourceManagementPreset.Development">
            <summary>
            Optimized for development and debugging scenarios.
            
            This preset is like having "developer-friendly training wheels" - it
            provides extensive monitoring and diagnostics while being forgiving
            about resource usage to help identify and fix issues.
            
            Configuration highlights:
            - Very high memory thresholds (2GB+)
            - Conservative cleanup to avoid masking issues
            - Detailed monitoring and metrics
            - Comprehensive resource tracking
            - Predictable behavior for debugging
            
            Best for:
            - Local development environments
            - Testing and QA environments
            - Debugging production issues
            - Performance profiling
            - Learning and experimentation
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions">
            <summary>
            Configuration options for resource management behavior.
            
            Resource management in distributed systems is like being a careful homeowner -
            you need to monitor your resources (memory, connections, handles) and clean up
            before things get out of control. This behavior helps prevent memory leaks,
            resource exhaustion, and performance degradation.
            
            Think of this as your "resource watchdog" that keeps an eye on what your
            application is consuming and takes action when necessary.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.MaxMemoryThresholdBytes">
            <summary>
            Gets or sets the maximum memory usage threshold in bytes before triggering cleanup.
            When memory usage exceeds this limit, the behavior will attempt various cleanup strategies.
            Default is 512MB.
            
            Set this based on your application's memory constraints:
            - Containerized apps: 50-80% of container memory limit
            - Server applications: 1-2GB depending on available RAM
            - Desktop applications: 256-512MB for responsive UI
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.MemoryGrowthRateThresholdBytesPerSecond">
            <summary>
            Gets or sets the memory growth rate threshold (bytes per second) that triggers warnings.
            This helps detect memory leaks by monitoring how quickly memory usage is growing.
            Default is 10MB/second.
            
            Rapid memory growth often indicates:
            - Memory leaks in request handlers
            - Unbounded caching
            - Large object accumulation
            - Resource handles not being disposed
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.AutoTriggerGarbageCollection">
            <summary>
            Gets or sets whether to automatically trigger garbage collection when memory pressure is detected.
            This can help reclaim memory but may impact performance due to GC pauses.
            Default is false - let the GC handle its own timing.
            
            Enable this for:
            - Memory-constrained environments
            - Long-running batch operations
            - Applications with predictable memory patterns
            
            Keep disabled for:
            - High-performance scenarios requiring consistent latency
            - Applications with unpredictable workloads
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.ForceFullGarbageCollection">
            <summary>
            Gets or sets whether to force a full garbage collection (all generations).
            This is more aggressive but can reclaim more memory at the cost of longer pauses.
            Only applies when AutoTriggerGarbageCollection is true.
            Default is false - use standard GC.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.MonitoringIntervalSeconds">
            <summary>
            Gets or sets the interval for monitoring resource usage (in seconds).
            More frequent monitoring provides better responsiveness but uses more CPU.
            Default is 30 seconds.
            
            Adjust based on your needs:
            - Critical applications: 10-15 seconds
            - Standard applications: 30-60 seconds
            - Background services: 60-300 seconds
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.CleanupStrategy">
            <summary>
            Gets or sets the cleanup strategy to use when resource thresholds are exceeded.
            Different strategies have different trade-offs between aggressiveness and performance impact.
            Default is Conservative.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.CollectDetailedMemoryStats">
            <summary>
            Gets or sets whether to collect detailed memory statistics for diagnostics.
            This provides valuable debugging information but adds overhead.
            Default is false - only enable for troubleshooting.
            
            Detailed stats include:
            - Generation-specific GC counts
            - Large object heap usage
            - Working set vs. managed memory
            - Memory pressure indicators
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.MaxTrackedDisposableResources">
            <summary>
            Gets or sets the maximum number of concurrent disposable resources to track.
            The behavior can track IDisposable resources and ensure they're properly cleaned up.
            Default is 1000 resources.
            
            Higher values provide better tracking but use more memory.
            Set to 0 to disable resource tracking.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.EnableDisposableResourceTracking">
            <summary>
            Gets or sets whether to track and clean up abandoned disposable resources.
            This helps prevent resource leaks from handlers that forget to dispose resources.
            Default is true.
            
            When enabled, the behavior will:
            - Track IDisposable objects created during request processing
            - Automatically dispose them if not disposed by the handler
            - Log warnings about undisposed resources
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.Options.ResourceManagementOptions.CustomCleanupAction">
            <summary>
            Gets or sets a custom action to execute when resource pressure is detected.
            This allows you to implement custom cleanup logic beyond the standard strategies.
            
            Example uses:
            - Clear application-specific caches
            - Close idle database connections
            - Flush buffers to disk
            - Notify monitoring systems
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext">
            <summary>
            Context information provided to custom cleanup actions.
            This gives your custom logic access to current resource state and metrics.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext.CurrentMemoryUsage">
            <summary>
            Gets the current memory usage in bytes.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext.BaselineMemoryUsage">
            <summary>
            Gets the memory usage when monitoring started, for calculating growth.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext.MemoryGrowthRate">
            <summary>
            Gets the rate of memory growth in bytes per second.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext.GarbageCollectionCount">
            <summary>
            Gets the number of garbage collections that have occurred.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext.CurrentRequestType">
            <summary>
            Gets the current request type being processed (null for background monitoring).
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext.PressureDetectedAt">
            <summary>
            Gets the timestamp when resource pressure was detected.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.ResourceManagement.Models.ResourcePressureContext.Properties">
            <summary>
            Gets custom properties that can be set by the resource management behavior.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Retry.Behaviors.RetryBehavior`2">
            <summary>
            Pipeline behavior that implements intelligent retry logic for handling transient failures.
            This behavior wraps request handlers with sophisticated retry mechanisms that can
            significantly improve the resilience of your distributed system.
            
            The retry logic follows these principles:
            1. Only retry exceptions that are likely to be transient
            2. Use exponential backoff to avoid overwhelming failing systems
            3. Respect total timeout limits to prevent hanging operations
            4. Provide detailed logging for debugging and monitoring
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Retry.Behaviors.RetryBehavior`2.#ctor(Microsoft.Extensions.Logging.ILogger{FS.Mediator.Features.Retry.Behaviors.RetryBehavior{`0,`1}},FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions)">
            <summary>
            Pipeline behavior that implements intelligent retry logic for handling transient failures.
            This behavior wraps request handlers with sophisticated retry mechanisms that can
            significantly improve the resilience of your distributed system.
            
            The retry logic follows these principles:
            1. Only retry exceptions that are likely to be transient
            2. Use exponential backoff to avoid overwhelming failing systems
            3. Respect total timeout limits to prevent hanging operations
            4. Provide detailed logging for debugging and monitoring
            </summary>
            <typeparam name="TRequest">The type of request being processed.</typeparam>
            <typeparam name="TResponse">The type of response returned by the request.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.Retry.Behaviors.RetryBehavior`2.HandleAsync(`0,FS.Mediator.Features.RequestHandling.Core.RequestHandlerDelegate{`1},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:FS.Mediator.Features.Retry.Behaviors.RetryBehavior`2.CalculateDelay(System.Int32)">
            <summary>
            Calculates the delay before the next retry attempt based on the configured strategy.
            This method implements the mathematical logic behind different retry strategies,
            each optimized for different failure scenarios.
            </summary>
            <param name="attemptNumber">Zero-based attempt number (0 = first retry)</param>
            <returns>The calculated delay before the next attempt</returns>
        </member>
        <member name="M:FS.Mediator.Features.Retry.Behaviors.RetryBehavior`2.CalculateJitteredDelay(System.Int32)">
            <summary>
            Calculates exponential backoff delay with added jitter to prevent thundering herd problems.
            The jitter uses a ±25% random variation to spread out retry attempts across time.
            </summary>
            <param name="attemptNumber">Zero-based attempt number</param>
            <returns>Exponential delay with random jitter applied</returns>
        </member>
        <member name="T:FS.Mediator.Features.Retry.Behaviors.Streaming.StreamingRetryBehavior`2">
            <summary>
            Streaming pipeline behavior that implements intelligent retry logic for stream operations.
            
            Retry for streaming is complex because streams can partially succeed. This implementation
            uses a "restart from beginning" strategy, which is the safest approach for most scenarios.
            The channel-based pattern allows us to handle retry logic with full try-catch capability
            while keeping yield statements completely separate.
            </summary>
            <typeparam name="TRequest">The type of streaming request</typeparam>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
        </member>
        <member name="T:FS.Mediator.Features.Retry.Models.Enums.RetryPreset">
            <summary>
            Predefined retry policy configurations for common scenarios.
            These presets represent battle-tested configurations that work well
            for typical distributed system challenges.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.RetryPreset.Conservative">
            <summary>
            Conservative retry policy with minimal attempts and fixed delays.
            Best for: Operations where speed is more important than resilience,
            or when you want to fail fast to avoid user frustration.
            Configuration: 2 retries, 500ms fixed delay, 10s total timeout
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.RetryPreset.Aggressive">
            <summary>
            Aggressive retry policy with more attempts and intelligent backoff.
            Best for: Critical operations that must succeed, background processes,
            or when user experience can tolerate longer wait times.
            Configuration: 5 retries, exponential backoff with jitter, 2min total timeout
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.RetryPreset.Database">
            <summary>
            Optimized for database operations and connection issues.
            Best for: Entity Framework operations, direct database calls,
            repository pattern implementations.
            Configuration: 3 retries, exponential backoff, database-specific exception handling
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.RetryPreset.HttpApi">
            <summary>
            Optimized for HTTP API calls and network operations.
            Best for: External API integrations, microservice communication,
            third-party service calls.
            Configuration: 4 retries, jittered exponential backoff, HTTP-specific exception handling
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Retry.Models.Enums.RetryStrategy">
            <summary>
            Defines the different retry timing strategies available.
            Each strategy represents a different mathematical approach to spacing retry attempts.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.RetryStrategy.FixedDelay">
            <summary>
            Wait the same amount of time between each retry attempt.
            Simple and predictable: delay, delay, delay...
            Best for: Simple scenarios where you want consistent timing
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.RetryStrategy.ExponentialBackoff">
            <summary>
            Double the wait time after each failed attempt.
            Mathematical progression: 1s, 2s, 4s, 8s...
            Best for: APIs with rate limiting, overloaded databases
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.RetryStrategy.ExponentialBackoffWithJitter">
            <summary>
            Exponential backoff plus random variation to prevent thundering herd.
            Adds randomness: 1s±jitter, 2s±jitter, 4s±jitter...
            Best for: High-concurrency scenarios with many clients
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Retry.Models.Enums.StreamingRetryStrategy">
            <summary>
            Defines different strategies for resuming failed streams.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.StreamingRetryStrategy.RestartFromBeginning">
            <summary>
            Always restart the stream from the beginning.
            This is the safest option but can be expensive for large streams.
            Best for: Small to medium streams, or when data consistency is critical.
            </summary>
        </member>
        <member name="F:FS.Mediator.Features.Retry.Models.Enums.StreamingRetryStrategy.ResumeFromLastPosition">
            <summary>
            Attempt to resume the stream from the last successfully processed position.
            This requires the stream handler to support positioning/seeking operations.
            Best for: Large streams where reprocessing is expensive, and when handlers support resumption.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions">
            <summary>
            Configuration options for retry policy behavior.
            This class encapsulates all the parameters needed to configure intelligent retry logic
            for handling transient failures in distributed systems.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions.MaxRetryAttempts">
            <summary>
            Gets or sets the maximum number of retry attempts.
            Think of this as your "persistence level" - how many times you're willing
            to try before giving up. Default is 3 attempts.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions.InitialDelay">
            <summary>
            Gets or sets the initial delay between retry attempts.
            This serves as the base timing for your retry strategy. Default is 1 second.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions.Strategy">
            <summary>
            Gets or sets the retry strategy to use.
            Different strategies work better for different scenarios:
            - FixedDelay: Good for consistent, predictable delays
            - ExponentialBackoff: Best for rate-limited APIs and overloaded systems
            - ExponentialBackoffWithJitter: Optimal for high-concurrency scenarios
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions.MaxTotalRetryTime">
            <summary>
            Gets or sets the maximum total time to spend on retries.
            This acts as a circuit breaker - even if you haven't used all retry attempts,
            you'll stop if this timeout is exceeded. Default is 30 seconds.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions.ShouldRetryPredicate">
            <summary>
            Gets or sets a function to determine if an exception should trigger a retry.
            This is your "retry decision engine" - you can customize which exceptions
            are worth retrying and which should fail immediately.
            By default, retries most common transient exceptions.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.Retry.Models.Options.RetryPolicyOptions.DefaultShouldRetryPredicate(System.Exception)">
            <summary>
            Default predicate that determines whether an exception warrants a retry attempt.
            This method embodies years of distributed systems wisdom about which failures
            are typically transient vs. permanent.
            </summary>
            <param name="exception">The exception to evaluate</param>
            <returns>True if the exception type suggests a retry might succeed</returns>
        </member>
        <member name="T:FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions">
            <summary>
            Configuration options for streaming retry behavior.
            
            Retry logic for streams is fundamentally different from regular requests because:
            1. Streams can partially succeed (yield some items before failing)
            2. Restarting an entire stream might be expensive or inappropriate
            3. State management becomes crucial (where do we resume from?)
            
            These options help you configure retry behavior that makes sense for your specific streaming scenarios.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions.MaxRetryAttempts">
            <summary>
            Gets or sets the maximum number of retry attempts for a failed stream.
            Each retry attempt will restart the entire stream from the beginning.
            Default is 2 attempts (3 total including initial attempt).
            
            Consider the cost of retrying: if your stream processes a million database records,
            retrying might be expensive. For such cases, you might prefer lower retry counts
            with better error handling in your stream handler.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions.InitialDelay">
            <summary>
            Gets or sets the initial delay before the first retry attempt.
            This delay helps avoid immediately retrying a failing operation,
            giving downstream services time to recover.
            Default is 2 seconds.
            
            For database streams, consider longer delays (5-10 seconds) to allow
            database connection pools to recover. For in-memory operations,
            shorter delays (500ms-1s) might be appropriate.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions.RetryStrategy">
            <summary>
            Gets or sets the retry strategy for calculating delays between attempts.
            Different strategies work better for different failure scenarios:
            
            - FixedDelay: Same delay between each retry (good for predictable failures)
            - ExponentialBackoff: Increasing delays (good for overloaded systems)
            - ExponentialBackoffWithJitter: Randomized increasing delays (best for high-concurrency)
            
            Default is ExponentialBackoff, which works well for most streaming scenarios.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions.MaxTotalRetryTime">
            <summary>
            Gets or sets the maximum total time to spend on retries for a single stream.
            Even if retry attempts remain, the operation will stop if this timeout is exceeded.
            Default is 5 minutes.
            
            This is crucial for streaming operations because they can run for long periods.
            Set this based on your business requirements: batch processing might tolerate
            longer timeouts (30-60 minutes), while user-facing streams should be shorter (1-5 minutes).
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions.ShouldRetryPredicate">
            <summary>
            Gets or sets a function to determine if an exception should trigger a retry.
            This is your "retry decision engine" that determines which exceptions are
            worth retrying and which should fail immediately.
            
            Default behavior retries common transient exceptions like network timeouts
            and database connection issues, but not business logic exceptions.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.Retry.Models.Options.StreamingRetryOptions.ResumeStrategy">
            <summary>
            Gets or sets the retry strategy for resuming streams.
            
            - RestartFromBeginning: Always restart the entire stream (safest, but potentially expensive)
            - ResumeFromLastPosition: Try to resume from where the stream failed (efficient, but requires handler support)
            
            Default is RestartFromBeginning because it's the safest option.
            ResumeFromLastPosition requires your stream handlers to support positioning/seeking.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Core.StreamRequestHandlerDelegate`1">
            <summary>
            Represents a streaming request handler delegate for pipeline behaviors.
            This is the streaming equivalent of RequestHandlerDelegate but for async enumerables.
            
            The key difference from regular handlers is that this returns an IAsyncEnumerable,
            which means data flows continuously rather than as a single response.
            Think of this as a "data faucet" that can be turned on to produce a stream of results.
            </summary>
            <typeparam name="TResponse">The type of each item in the stream</typeparam>
            <returns>An async enumerable that yields results over time</returns>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Core.IStreamPipelineBehavior`2">
            <summary>
            Defines a pipeline behavior specifically designed for streaming requests.
            
            Streaming behaviors are fundamentally different from regular behaviors because:
            1. They work with continuous data flows rather than single responses
            2. They need to handle partial success/failure scenarios
            3. They must respect the lazy evaluation nature of IAsyncEnumerable
            4. They can apply transformations to individual items in the stream
            
            This interface allows you to implement cross-cutting concerns like logging,
            error handling, and data transformation for streaming operations while
            maintaining the performance benefits of streaming (low memory usage, 
            immediate availability of first results, etc.).
            </summary>
            <typeparam name="TRequest">The type of streaming request being processed</typeparam>
            <typeparam name="TResponse">The type of each item yielded by the stream</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.StreamHandling.Core.IStreamPipelineBehavior`2.HandleAsync(`0,FS.Mediator.Features.StreamHandling.Core.StreamRequestHandlerDelegate{`1},System.Threading.CancellationToken)">
            <summary>
            Handles the streaming request within the pipeline.
            
            This method wraps around the next handler in the pipeline and can:
            - Log the start and end of streaming operations
            - Transform individual items as they flow through
            - Handle errors that occur during streaming
            - Implement retry logic for failed streams
            - Apply circuit breaker patterns to protect downstream services
            - Cache or buffer stream results
            
            Important: Unlike regular behaviors, this method must preserve the streaming
            nature of the operation. Don't convert the IAsyncEnumerable to a list or
            array unless absolutely necessary, as this defeats the purpose of streaming.
            </summary>
            <param name="request">The streaming request being processed</param>
            <param name="next">The next handler in the pipeline (could be another behavior or the actual handler)</param>
            <param name="cancellationToken">Cancellation token for the streaming operation</param>
            <returns>An async enumerable that yields transformed/processed results</returns>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Core.IStreamRequest`1">
            <summary>
            Marker interface for streaming requests that return an async enumerable of TResponse.
            Use this interface when you need to stream large amounts of data or provide real-time updates.
            This is particularly useful for scenarios like:
            - Large data set queries (avoiding memory issues)
            - Real-time data feeds
            - Progressive data loading
            </summary>
            <typeparam name="TResponse">The type of each item in the stream.</typeparam>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Core.IStreamRequestHandler`2">
            <summary>
            Defines a handler for streaming requests that return an async enumerable of TResponse.
            This interface is designed for scenarios where you need to process and return large amounts of data
            without loading everything into memory at once. Perfect for:
            - Database queries with millions of records
            - File processing that yields results incrementally  
            - Real-time data feeds that continue indefinitely
            - API responses that benefit from progressive loading
            </summary>
            <typeparam name="TRequest">The type of streaming request being handled.</typeparam>
            <typeparam name="TResponse">The type of each item yielded in the stream.</typeparam>
        </member>
        <member name="M:FS.Mediator.Features.StreamHandling.Core.IStreamRequestHandler`2.HandleAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Handles the specified streaming request and yields results asynchronously.
            This method should use 'yield return' to provide items one at a time,
            allowing the caller to process each item as it becomes available rather than
            waiting for the entire result set to be computed.
            </summary>
            <param name="request">The streaming request to handle.</param>
            <param name="cancellationToken">A cancellation token to cancel the streaming operation.</param>
            <returns>An async enumerable that yields results as they become available.</returns>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Exceptions.StreamingOperationException">
            <summary>
            Specialized exception that provides detailed information about streaming operation failures.
            
            Streaming operations can fail in unique ways:
            - They might succeed partially (yield some items before failing)
            - They might fail on specific items while others succeed
            - They might fail due to downstream service issues after producing results
            
            This exception captures these nuances to help with debugging and error handling.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.StreamHandling.Exceptions.StreamingOperationException.#ctor(System.String,System.Int64,System.Exception)">
            <summary>
            Initializes a new streaming operation exception.
            </summary>
            <param name="message">The error message</param>
            <param name="streamPosition">The position in the stream where the error occurred (-1 if unknown)</param>
            <param name="innerException">The underlying exception that caused the stream to fail</param>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Exceptions.StreamingOperationException.StreamPosition">
            <summary>
            Gets the position in the stream where the failure occurred.
            -1 indicates the position is unknown or the failure happened before streaming started.
            This is valuable for retry logic - you might want to retry from this position.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Exceptions.StreamingOperationException.FailureTime">
            <summary>
            Gets the timestamp when the streaming operation failed.
            Useful for debugging and understanding failure patterns over time.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Exceptions.StreamingOperationException.SuccessfulItemCount">
            <summary>
            Gets or sets the number of items that were successfully yielded before the failure.
            This helps determine if the stream was partially successful.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics">
            <summary>
            Provides metadata about a streaming operation for monitoring and debugging.
            This class captures important metrics that help you understand the performance
            and health of your streaming operations.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.StartTime">
            <summary>
            Gets or sets when the streaming operation started.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.EndTime">
            <summary>
            Gets or sets when the streaming operation completed (successfully or with error).
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.Duration">
            <summary>
            Gets the total duration of the streaming operation.
            Returns null if the operation hasn't completed yet.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.ItemCount">
            <summary>
            Gets or sets the total number of items yielded by the stream.
            This is incremented as items flow through the pipeline.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.ErrorCount">
            <summary>
            Gets or sets the number of errors that occurred during streaming.
            This includes both recoverable errors (handled by retry logic) and fatal errors.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.CompletedSuccessfully">
            <summary>
            Gets or sets whether the streaming operation completed successfully.
            True means the stream reached its natural end without unhandled errors.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.LastError">
            <summary>
            Gets or sets the last error that occurred during streaming.
            This is useful for debugging when operations fail.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingOperationMetrics.ItemsPerSecond">
            <summary>
            Gets the average items per second processed by the stream.
            This is a key performance indicator for streaming operations.
            Returns null if the operation hasn't completed or no items were processed.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext">
            <summary>
            Context object that flows through the streaming pipeline, carrying metadata and state.
            This is similar to how HTTP contexts flow through web request pipelines.
            
            The context allows behaviors to:
            - Share state and metadata across the pipeline
            - Track performance metrics
            - Coordinate between different behaviors
            - Maintain correlation IDs for distributed tracing
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new streaming pipeline context.
            </summary>
            <param name="requestType">The type of the streaming request</param>
            <param name="correlationId">Optional correlation ID for tracing</param>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.RequestType">
            <summary>
            Gets the type of the streaming request being processed.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.CorrelationId">
            <summary>
            Gets the correlation ID for this streaming operation.
            Useful for distributed tracing and debugging across multiple services.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.Properties">
            <summary>
            Gets a dictionary for storing custom properties that behaviors can use to communicate.
            For example, a caching behavior might store cache metadata here.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.Metrics">
            <summary>
            Gets the metrics being collected for this streaming operation.
            Behaviors can update these metrics to provide insights into performance and health.
            </summary>
        </member>
        <member name="P:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.IsCancelled">
            <summary>
            Gets or sets whether the streaming operation has been cancelled.
            Behaviors can check this to determine if they should continue processing.
            </summary>
        </member>
        <member name="M:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.SetProperty(System.String,System.Object)">
            <summary>
            Adds or updates a property in the context.
            </summary>
            <param name="key">The property key</param>
            <param name="value">The property value</param>
        </member>
        <member name="M:FS.Mediator.Features.StreamHandling.Models.StreamingPipelineContext.GetProperty``1(System.String)">
            <summary>
            Gets a property from the context.
            </summary>
            <typeparam name="T">The expected type of the property</typeparam>
            <param name="key">The property key</param>
            <returns>The property value, or default(T) if not found</returns>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Models.StreamingResult`1">
            <summary>
            Represents the result of a streaming operation with error information.
            This allows us to handle errors without using try-catch around yield statements.
            </summary>
        </member>
        <member name="T:FS.Mediator.Features.StreamHandling.Models.StreamProcessingMetrics">
            <summary>
            Metrics tracking class for streaming operations.
            This class encapsulates all the performance and health metrics we track during streaming.
            </summary>
        </member>
    </members>
</doc>
